import "vcs";
import "banks";

//;===============================================================================
//; A S S E M B L E R - S W I T C H E S
//;===============================================================================

let OPTIMIZE        = false; //                     ; enable some possible optimizations
let FILL_OPT        = true; //                     ; fill optimized bytes with NOPs
let SCREENSAVER     = true; //                     ; compile with screensaver code
let NOSCREENSAVER     = false; //                     ; compile with screensaver code

let TRAINER         = false; //                     ; enable training mode
let NTSC            = true; //                     ; compile for NTSC
#[compile_if(NTSC)] let FRAMERATE       = 60; 
#[compile_if(NTSC)] let STARTTIME       = 0x20;
#[compile_if(!NTSC)] let FRAMERATE       = 60; 
#[compile_if(!NTSC)] let STARTTIME       = 0x20; //                   ; $24   ..adjust the PAL timer


//;===============================================================================
//; C O N S T A N T S
//;===============================================================================

//; initial value for the random number generator:
let RAND_SEED       = 0xc4                   ; //defines the start scene of the game

//; color constants:
#[compile_if(NTSC)] let BROWN           = 0x12;
#[compile_if(NTSC)] let YELLOW          = 0x1e;
#[compile_if(NTSC)] let ORANGE          = 0x3e;
#[compile_if(NTSC)] let RED             = 0x48;
#[compile_if(NTSC)] let GREEN           = 0xd6;
#[compile_if(NTSC)] let BLUE            = 0xa4;
#[compile_if(NTSC)] let YELLOW_GREEN    = 0xc8;
#[compile_if(NTSC)] let PINK            = 0x4a;

#[compile_if(!NTSC)] let BROWN           = 0x22;
#[compile_if(!NTSC)] let YELLOW          = 0x2e;
#[compile_if(!NTSC)] let ORANGE          = 0x4e;
#[compile_if(!NTSC)] let RED             = 0x68;
#[compile_if(!NTSC)] let GREEN           = 0x56;
#[compile_if(!NTSC)] let BLUE            = 0xb4;
#[compile_if(!NTSC)] let YELLOW_GREEN    = 0x78;
#[compile_if(!NTSC)] let PINK            = 0x4a;

let BLACK           = 0x00;
let GREY            = 0x06;
let WHITE           = 0x0e;
let DARK_GREEN      = GREEN  - 0x04;
let DARK_RED        = RED    - 0x06;

//; x constants:
let SCREENWIDTH     = 160;
let SCREENWIDTHDIV2 = (SCREENWIDTH/2 - 4);
let SCREENWIDTHDIV2M4 = (SCREENWIDTHDIV2 - 4);
let XMIN_HARRY      = 8                     ; //minimal position before next left scene
let XMAX_HARRY      = 148                   ; //maximal position before next right scene

//; y-size constants:
let HARRY_H         = 22                    ; //height of Harry
let OBJECT_H        = 16                    ; //maximum object height
let DIGIT_H         = 8                     ; //height of the score and time digits
let COPYRIGHT_H     = 16                    ; //height of copyright message

//; some defined y-positions of Harry:
let JUNGLE_GROUND   = 32;
let UNDER_GROUND    = 86;

//; positions of Harry at ladder:
let LADDER_TOP      = 11;
let LADDER_BOTTOM   = 22;

//; lenght of a jump:
let JUMP_LEN        = 32;

//; Harry pattern ids:
let ID_KNEEING      = 0;
let ID_RUNNING4     = 4;                    ; //0..3 are running ids too
let ID_STANDING     = 5;
let ID_SWINGING     = 6;
let ID_CLIMBING     = 7;

//; objectType ids:
let ID_STATIONARY   = 4;                     ; //stationary logs (0..5 are log types)
let ID_FIRE         = 6;
let ID_COBRA        = 7;
let ID_TREASURES    = 8;                    ; //8..11 are treasures
let ID_NOTHING      = 12;

//; sceneType constants:
let HOLE1_SCENE     = 0;
let HOLE3_SCENE     = 1;
let CROCO_SCENE     = 4;
let TREASURE_SCENE  = 5;

//; flags for ladder:
let NOLADDER        = 0b00000000;
let WITHLADDER      = 0b11111111;

//; flags for pit color:
let BLUEPIT         = 0b00000000;
let BLACKPIT        = 0b10000000;

//; offsets in SoundTab for tunes:
let SOUND_JUMP      = 0x20;                   ; //Harry is jumping
let SOUND_TREASURE  = 0x25;                   ; //Harry is collecting a treasure
let SOUND_DEAD      = 0x31;                   ; //Harry is killed
let SOUND_FALLING   = 0x53;                   ; //Harry is falling into a hole

//; values for NUSIZx:
let ONE_COPY        = 0b000;
let TWO_COPIES      = 0b001;
let TWO_WIDE_COPIES = 0b010;
let THREE_COPIES    = 0b011;
let DOUBLE_SIZE     = 0b101;
let THREE_MED_COPIES = 0b110;
let QUAD_SIZE       = 0b111;


//; mask for SWCHB:
let BW_MASK         = 0b1000;                 ; //black and white bit

//; SWCHA joystick bits:
let MOVE_RIGHT      = 0b0111;
let MOVE_LEFT       = 0b1011;
let MOVE_DOWN       = 0b1101;
let MOVE_UP         = 0b1110;
let NO_MOVE         = 0b1111;
let JOY_RIGHT       = ~MOVE_RIGHT & NO_MOVE;
let JOY_LEFT        = ~MOVE_LEFT  & NO_MOVE;
let JOY_DOWN        = ~MOVE_DOWN  & NO_MOVE;
let JOY_UP          = ~MOVE_UP    & NO_MOVE;
let JOY_HORZ        = JOY_RIGHT|JOY_LEFT;
let JOY_VERT        = JOY_DOWN |JOY_UP;

//; values for ENAxy:
let DISABLE         = 0b00;
let ENABLE          = 0b10                   ; //value for enabling a missile

//; values for REFPx:
let NOREFLECT       = 0b0000;
let REFLECT         = 0b1000;



in ram {

//;===============================================================================
//; Z P - V A R I A B L E S
//;===============================================================================

//    SEG.U   Variables
//    ORG     $80

var livesPat   @ 0x80 : u8; //         .byte   ;           number of lives, stored as displayed pattern ($a0 = 3, $80 = 2, $00 = 1)
var random     @ 0x81 : u8; //         .byte   ;           all scenes are generated randomly with this
var random2    @ 0x82 : u8; //         .byte   ;           used for random object animation
var joystick   @ 0x83 : u8; //         .byte   ;           stores joystick directions
var fireButton @ 0x84 : u8; //         .byte   ;           stores fire button state
var hitLiana   @ 0x85 : u8; //         .byte   ;           Harry collided with liana? (bit 6 = 1 -> yes)
var cxHarry    @ 0x86 : u8; //         .byte   ;           Harry's collisions (stored but _never_ read!)
#[compile_if(SCREENSAVER)] var SS_XOR @ 0x87 : u8; //             .byte   ;           change colors in screensaver mode (0/$01..$ff)
#[compile_if(SCREENSAVER)] var SS_Mask @ 0x88 : u8; //             .byte   ;           darker colors in screensaver mode ($ff/$f7)
#[compile_if(!SCREENSAVER)] var dummy @ 0x87 : u16; //             .word

var colorLst       @ 0x89 : [u8; 9];//           ds 9    ;           some (mostly constant!?) colors
var lianaBottom    @ 0x92 : u8; //       .byte   ;           bottom row of liana
var objectType     @ 0x93 : u8; //      .byte   ;           type of the objects on the ground (hazards & treasures)
var sceneType      @ 0x94 : u8; //       .byte   ;           type of the scene (0..7
var HMFineLst      @ 0x95 : [u8; 3];//       ds 3    ;           fine positioning value for: Harry, ground-object, underground-object
var HMCoarseLst    @ 0x98 : [u8; 3];//      ds 3    ;           coars positioning value for: Harry, ground-object, underground-object
var posLeftBranch  @ 0x9b  : u8; //     .byte   ;           values for positioning left branch graphics
var posRightBranch @ 0x9c : u8; //    .byte   ;           values for positioning right branch graphics
var ladderFlag     @ 0x9d : u8; //      .byte   ;           0 = no ladder, $ff = with ladder
var noGameScroll   @ 0x9e : u8; //      .byte   ;           0 = game is running
var PF2QuickSand   @ 0x9f : u8; //      .byte   ;           PF2 data for top quicksand row
var PF2Lst         @ 0xa0 : [u8; 7];//        ds 7    ;           copied pit pattern data
var objColLst      @ 0xa7 : [u8; 7];//         ds 7    ;           copied object colors
var objPatLst      @ 0xae : [u8; 7];//         ds 7    ;           copied object patterns
var PatPtr         @ 0xb5 : [u8;20];
var harryPatPtr    @ 0xb5 : u16;//       .word   ; = $b5     pointer to Pitfall Harry patterns
var harryPatPtr8   @ 0xb5 : [u8;2];//       .word   ; = $b5     pointer to Pitfall Harry patterns

var objPatPtr      @ 0xb7 : u16;//       .word   ;           pointer to object (hazards, treasure) patterns
var objPatPtr8     @ 0xb7 : [u8;2];//       .word   ;           pointer to object (hazards, treasure) patterns

var harryColPtr    @ 0xb9 : u16;//       .word   ;           pointer to Pitfall Harry colors
var harryColPtr8   @ 0xb9 : [u8;2];//       .word   ;           pointer to Pitfall Harry colors

var objColPtr      @ 0xbb : u16;//       .word   ;           pointer to object (hazards, treasure) colors
var objColPtr8     @ 0xbb : [u8;2];//       .word   ;           pointer to object (hazards, treasure) colors

var wallPatPtr     @ 0xbd : u16;//       .word   ;           pointer to wall patterns
var wallPatPtr8    @ 0xbd : [u8;2];//       .word   ;           pointer to wall patterns

var wallColPtr     @ 0xbf  : u16;//       .word   ;           pointer to wall colors
var wallColPtr8    @ 0xbf : [u8;2];//       .word   ;           pointer to wall colors

var undrPatPtr     @ 0xc1 : u16;//       .word   ;           pointer to underground object (wall, scorpion) patterns
var undrPatPtr8    @ 0xc1 : [u8;2];//       .word   ;           pointer to underground object (wall, scorpion) patterns

var undrColPtr     @ 0xc3 : u16;//      .word   ;           pointer to underground object (wall, scorpion) colors
var undrColPtr8    @ 0xc3 : [u8;2];//      .word   ;           pointer to underground object (wall, scorpion) colors

var digitPtr       @ 0xc5 : [u8; 12];////      ds.w 6  ;           pointers for score display
var digitPtra      @ 0xc5 : u16;////      ds.w 6  ;           pointers for score display
var digitPtr2      @ 0xc7 : [u8; 12];////      ds.w 6  ;           pointers for score display
var digitPtr2a     @ 0xc7 : u16;////      ds.w 6  ;           pointers for score display
var digitPtr4a     @ 0xc9 : u16;////      ds.w 6  ;           pointers for score display
var digitPtr6a     @ 0xcb : u16;////      ds.w 6  ;           pointers for score display
var digitPtr8a     @ 0xcd : u16;////      ds.w 6  ;           pointers for score display
var digitPtr10a    @ 0xcf : u16;////      ds.w 6  ;           pointers for score display

  //  IF SCREENSAVER
#[compile_if(SCREENSAVER)] var SS_Delay @ 0xd1 : u8; //            .byte   ; = $d1
#[compile_if(SCREENSAVER)] var SS_DelayLo @ 0xd2 : u8; //        .byte
var frameCnt       @ 0xd3 : u8;//           .byte   ;           frame counter (increased every frame)
var nusize1        @ 0xd4 : u8;//           .byte   ;           number of ground-objects
var scoreHi        @ 0xd5 : u8;//           .byte   ;           3 BCD score bytes
var scoreHi8       @ 0xd5 : [u8;20];//           .byte   ;           3 BCD score bytes
var scoreMed       @ 0xd6 : u8;//           .byte
var scoreLo        @ 0xd7 : u8;//           .byte
var timerHi        @ 0xd8 : u8;//           .byte   ;           2 BCD timer bytes
var timerMed       @ 0xd9 : u8;//           .byte
var timerLo        @ 0xda : u8;//          .byte   ;           decease timer every 60th frame
var hmblSum        @ 0xdb : u8;//          .byte   ;           used to generate liana line
var hmblAdd        @ 0xdc : u8;//          .byte   ;           depends on the liana angle
var hmblDir        @ 0xdd : u8;//          .byte   ;           move liana +/-1
var lianaPosHi     @ 0xde : u8;//         .byte   ;           high x-position of liana bottom
var lianaPosLo     @ 0xdf : u8;//        .byte   ;           low x-position of liana bottom
var soundIdx       @ 0xe0 : u8;//        .byte   ;           index of sound-table (0 = no sound)
var PosPtr         @ 0xe1 : [u8;3]; 
var xPosHarry8         @ 0xe1 : [u8;3]; 
var xPosHarry      @ 0xe1 : u8;//        .byte   ;           x-position of Pitfall Harry
var xPosObject     @ 0xe2 : u8;//        .byte   ;           x-position of hazards & treasures
var xPosScorpion   @ 0xe3 : u8;//      .byte   ;           x-position of the scorpion (and the wall)
var patIdHarry     @ 0xe4 : u8;//      .byte   ;           id of the animation for Harry
var reflectHarry   @ 0xe5 : u8;//      .byte   ;           reflect Harry graphics
var reflectScorpion @ 0xe6  : u8;//   .byte   ;           reflect scorpion graphics
var jumpIndex      @ 0xe7 : u8;//      .byte   ;           index of jump-table (0..32)
var oldJoystick    @ 0xe8 : u8;//      .byte   ;           saved old joystick direction
var yPosHarry      @ 0xe9 : u8;//      .byte   ;           y-position of Pitfall Harry
var atLiana        @ 0xea : u8;//      .byte   ;           Harry at liana? (0 = no, -1 = yes)
var treePat        @ 0xeb : u8;//      .byte   ;           id of the leaves pattern (0..3)
var climbPos      @ 0xec : u8;//      .byte   ;           position of Harry at ladder (0/11..22)
var treasureBits  @ 0xed : [u8; 4];//      ds 4    ;           remember which treasures haven't been found
var treasureCnt   @ 0xf1 : u8;//      .byte   ; = $f1     number of remaining treasures-1
var patOfsHarry   @ 0xf2 : u8;//      .byte   ;           pattern offset (5 while kneeing, 0 else)
var soundDelay    @ 0xf3 : u8;//      .byte   ;           play a new note every 4th frame
var xPosQuickSand @ 0xf4: u8;//      .byte   ;           border of quicksand
var jumpMode @ 0xf5 : u8;//         .byte   ; = $f5     similar to jumpIndex (JTZ: superfluous?)
var temp @ 0xf6 : [u8;3];
var temp1 @ 0xf6  : u8;//         .byte
var temp2 @ 0xf7      : u8;//         .byte
var temp3 @ 0xf8      : u8;//         .byte

var oram @ 0x00 : [u8; 0xff];
}


in rom {
  START:
  nointerrupt = true;       // sei
  decimal = false;          // cld
  x = 0x00;                 // ldx #$00;
Reset:
  a = 0x00;                 // lda #$00;

loopClear:
  oram[x] = a;              // sta    $00,x            ; 4
  s = x;                    // txs
  x++;                      // inx
  goto loopClear if !zero;  // bne loopClear
  
  InitGame();               // jsr InitGame

MainLoop:
  x = 8;                    // ldx    #8
loopColors:
  a = ColorTab[x];          // lda ColorTab, x
#[compile_if(SCREENSAVER)] 
  a = a ^ SS_XOR;           // eor    SS_XOR           ; 3
#[compile_if(SCREENSAVER)] 
  a = a & SS_Mask;          // and    SS_Mask          ; 3
#[compile_if(!SCREENSAVER)] 
  nop(4);
  
  colorLst[x] = a;          // sta    colorLst,x       ; 4                 store color in list
  cmp(x, 4);                // cpx    #4               ; 2
  goto skipTIA if carry;    // bcs    .skipTIA         ; 2³
  COLUP[x] = a;             // sta    COLUP0,x         ; 4                 store color in TIA too

skipTIA:
  x--;                      //     dex                     ; 2
  goto loopColors if !negative; //     bpl    .loopColors      ; 2³
/*

; process underground objects (scorpion, wall):
; Only one object at a time is visible, but two different
; pointer sets are used, because the wall is much taller than
; the scorpion.
; JTZ: two color pointers aren't necessary!
*/
  y = <:&ScorpionColor ;  //       ldy    #<ScorpionColor  ; 2
  x = <:&Scorpion0; //     ldx    #<Scorpion0      ; 2
  a = xPosScorpion; //     lda    xPosScorpion     ; 3
  a = a >>> 1;       //     lsr                     ; 2                 animate scorpion
  goto scorpion0 if !carry; //     bcc    .scorpion0       ; 2³

  x = <:(&Scorpion1 as *u8); //     ldx    #<Scorpion1      ; 2

scorpion0:
  a = <:&Nothing; //   lda    #<Nothing        ; 2
  wallPatPtr8[0] = a;
  a = ladderFlag; //     lda    ladderFlag       ; 3                 ladder in scene

  goto noLadder if zero; //     beq    .noLadder        ; 2³                 no, skip
  y = <:&WallColor; //     ldy    #<WallColor      ; 2                  yes,..

  x = <:&Wall;      //     ldx    #<Wall           ; 2
  wallPatPtr8[0] = x; //    stx    wallPatPtr       ; 3                 ..load pointers at ladder data
  wallColPtr8[0] = y;  //   sty    wallColPtr       ; 3

noLadder:
    undrPatPtr8[0] = x; //     stx    undrPatPtr       ; 3                 set scorpion or ladder pointers
    undrColPtr8[0] = y; //     sty    undrColPtr       ; 3
// ; calculate pits, quicksand etc.:
  x = sceneType;    //     ldx    sceneType        ; 3
  a = LadderTab[x]; //     lda    LadderTab,x      ; 4                 blue swamp?
  goto noPit if !negative; //     bpl    .noPit           ; 2³                 yes, skip

  a = colorLst[4]; //     lda    colorLst+4       ; 3                  no, black tar pit
  colorLst[8] = a; //     sta    colorLst+8       ; 3
noPit:
  y = 0; // ldy    #0               ; 2                 disable quicksand
  a = GroundTypeTab[x]; //     lda    GroundTypeTab,x  ; 4
  goto noQuickSand if !negative; //     bpl    .noQuickSand     ; 2³
  a = yPosHarry; //     lda    yPosHarry        ; 3
  cmp(a,55); //     cmp    #55              ; 2                 Harry in underground?

   goto doQuickSand if carry; //     bcs    .doQuickSand     ; 2³                 yes, animate quicksand

  cmp(a, JUNGLE_GROUND + 1); //     cmp    #JUNGLE_GROUND+1 ; 2                 stop quicksand animation when..
  goto stopQuickSand if carry; //     bcs    .stopQuickSand   ; 2³                ..Harry is falling into the pit
doQuickSand:
  a = noGameScroll; //     lda    noGameScroll     ; 3                 game running?
  goto stopQuickSand if !zero; //     bne    .stopQuickSand   ; 2³                 no, skip
  a = frameCnt; //     lda    frameCnt         ; 3
  a = a >>> 1; //     lsr                     ; 2
  a = a >>> 1; //     lsr                     ; 2
  push(a); //     pha                     ; 3
  a = a >>> 1; //    lsr                     ; 2
  a = a >>> 1; //    lsr                     ; 2
  a = a >>> 1; //    lsr                     ; 2
  a = a >>> 1; //    lsr                     ; 2
  x = a; //     tax                     ; 2                 x = framecount / 64

  a = pop(); //     pla                     ; 4                 only bits 2..5 of framecounter used
  a = a & QuickSandTab2[x]; //     and    QuickSandTab+2,x ; 4                 calculate size of the quicksand pit
  a = a ^ QuickSandTab[x]; //     eor    QuickSandTab,x   ; 4
  push(a); //     pha                     ; 3
  y = a; //     tay                     ; 2
  a = QuickSandSize[y]; //     lda    QuickSandSize,y  ; 4
  y = a; //     tay                     ; 2
  a = pop(); //     pla                     ; 4
  carry = false; //     clc                     ; 2
  a = a +#16; //     adc    #16              ; 2
noQuickSand:
  carry = false; //     clc                     ; 2
  xPosQuickSand = y; //     sty    xPosQuickSand    ; 3
  a = a +#6; //    adc    #6               ; 2
  y = a; //     tay                     ; 2
  x = 6; //     ldx    #6               ; 2
  a = ladderFlag; //     lda    ladderFlag       ; 3                 no swamp etc. when ladder
  a = a ^ 0xff; //     eor    #$ff             ; 2
  temp1 = a; //     sta    temp1            ; 3
loopPF2Lst:
  a = OneHole[y]; //    lda    PF2PatTab,y      ; 4
  PF2Lst[x] = a; //     sta    PF2Lst,x         ; 4
  a = a | temp1; //     ora    temp1            ; 3
  PF2QuickSand = a; //    sta    PF2QuickSand     ; 3
  y--; //     dey                     ; 2
  x--; //     dex                     ; 2
  goto loopPF2Lst if !negative; //     bpl    .loopPF2Lst      ; 2³ 
stopQuickSand:
//; calculate x-positioning values:
  x = 2; //     ldx    #2               ; 2
  a = 0; //     lda    #0               ; 2

#[compile_if(SCREENSAVER)] y = SS_Delay;
#[compile_if(SCREENSAVER)] goto skipHarryPos if negative;
  /*
  IF SCREENSAVER
    ldy    SS_Delay         ; 3                 game running?
    bmi    .skipHarryPos    ; 2³                 no, don't draw Harry
  ELSE
  */
#[compile_if(!SCREENSAVER)] y = noGameScroll; //   ldy    noGameScroll     ;                   TODO: bugfix, wall isn't drawn
#[compile_if(!SCREENSAVER)] goto skipHarryPos if !zero; //     bne    .skipHarryPos    ; 2³                 no, don't draw Harry
  /*
  ENDIF
*/
loopPos:
  a = xPosHarry8[x]; //     lda    xPosHarry,x      ; 4
skipHarryPos:
  CalcPosX(); //     jsr    CalcPosX         ; 6

  a = HMFineLst[x]; //    sta    HMFineLst,x      ; 4
  HMCoarseLst[x] = y; //     sty    HMCoarseLst,x    ; 4
  hmblSum = x; //     stx    hmblSum          ; 3                 -> hmblSum = 0
  x--; //     dex                     ; 2
  goto loopPos if !negative; //     bpl    .loopPos         ; 2³

//; load branches x-positioning values:
  x = treePat;  // ldx    treePat          ; 3
  a = BranchPosLTab[x]; //     lda    BranchPosLTab,x  ; 4
  posLeftBranch = a; //     sta    posLeftBranch    ; 3
  a = BranchPosRTab[x]; //     lda    BranchPosRTab,x  ; 4
  posRightBranch = a; //     sta    posRightBranch   ; 3

//; copy bottom object data:
  y = 14; //     ldy    #14              ; 2

  x = 6; //     ldx    #6               ; 2

loopObjLst:
  a = (objColPtr as *u8)[y]; // lda    (objColPtr),y    ; 5

  #[compile_if(SCREENSAVER)] a = a ^ SS_XOR;
  #[compile_if(SCREENSAVER)] a = a & SS_Mask;
/*
  IF SCREENSAVER
    eor    SS_XOR           ; 3
    and    SS_Mask          ; 3
    */
  #[compile_if(!SCREENSAVER)] nop(4);
  /*
  ELSE
    FILL_NOP 4
  ENDIF
  */
  objColLst[x] = a; //     sta    objColLst,x      ; 4
  a = (objPatPtr as *u8)[y]; //     lda    (objPatPtr),y    ; 5
  objPatLst[x] = a;//     sta    objPatLst,x      ; 4
  y--; //    dey                     ; 2
  x--; //    dex                     ; 2
  goto loopObjLst if !negative; //     bpl    .loopObjLst      ; 2³
waitTim1:
  a = INTIM; //a = vcs.timer.value; //     lda    INTIM            ; 4

  goto waitTim1 if !zero; //     bne    .waitTim         ; 2³
  WSYNC = a; //     sta    WSYNC            ; 3

  vcs.hmove.apply = a; //     sta    HMOVE            ; 3
  vcs.sync.vblank = a; //     sta    VBLANK           ; 3
  vcs.collision.clear = a; //     sta    CXCLR            ; 3
  temp3 = a; //     sta    temp3            ; 3                 don't show anything before score
  ShowDigits(); //     jsr    ShowDigits       ; 6                 draw score
//;---------------------------------------
//  ; set digitPtrs for timer:
  x = (&timerHi as u8 - &scoreHi as u8); //    ldx    #timerHi-scoreHi ; 2
  y = 2; //    ldy    #2               ; 2                 minutes
  BCD2DigitPtrs(); //     jsr    BCD2DigitPtrs    ; 6
  x++; //     inx                     ; 2                 seconds
  y = 8; //     ldy    #8               ; 2
  BCD2DigitPtrs(); //     jsr    BCD2DigitPtrs    ; 6
  a = livesPat; //     lda    livesPat         ; 3                 show lives before time
  temp3 = a; //     sta    temp3            ; 3
  a = <:(&Space); //     lda    #<Space          ; 2

  digitPtr[0] = a;  // sta    digitPtr         ; 3
  y = digitPtr[2]; // ldy    digitPtr+2       ; 3
  goto noSpace if !zero; //     bne    .noSpace         ; 2³                replaced leading zero in timer with space
  digitPtr[2] = a;     //     sta    digitPtr+2       ; 3

  /*
    */
noSpace:
  a = <:(&DoublePoint[0]); //     lda    #<DoublePoint    ; 2
  digitPtr[6] = a; //     sta    digitPtr+6       ; 3
  ShowDigits();   //     jsr    ShowDigits       ; 6                 draw lives and timer
  WSYNC = a ;     //     sta    WSYNC            ; 3

/*
;---------------------------------------
; Here starts the main kernel. Actually there are nine(!)
; specialized kernel loops. Together with extra code before and
; after the loops, this makes the kernel very huge [~900 bytes).

; draw branches at top of the logs:
*/
  vcs.hmove.apply = a; //     sta    HMOVE            ; 3
  a = 0x00; //     lda    #$00             ; 2
  vcs.vdelay.player1 = a; //     sta    VDELP1           ; 3                 disable vertical delay for object
  GRP0 = a; //vcs.pattern.player1 = a; //     sta    GRP0             ; 3
  GRP1 = a; //vcs.pattern.player2 = a; //     sta    GRP1             ; 3
  a = colorLst[5]; //     lda    colorLst+5       ; 3                 branches color (always BROWN-2)
  COLUP0 = a; //vcs.color.player1 = a; //     sta    COLUP0           ; 3
  COLUP1 = a; //vcs.color.player2 = a; //     sta    COLUP1           ; 3
  a = TWO_WIDE_COPIES; //     lda    #TWO_WIDE_COPIES ; 2                 draw four branches
  NUSIZ0 = a; //vcs.control.player1 = a; //     sta    NUSIZ0           ; 3
  NUSIZ1 = a; //vcs.control.player2 = a; //     sta    NUSIZ1           ; 3
  a = posLeftBranch; //     lda    posLeftBranch    ; 3
  a = a & 0x0f; //     and    #$0f             ; 2
  x = a; //     tax                     ; 2                 x = coarse x-positioning value of left branch
  a = posRightBranch; //     lda    posRightBranch   ; 3
  a = a & 0x0f; //     and    #$0f             ; 2
  y = a; //     tay                     ; 2                 y = coarse x-positioning value of right branch
  WSYNC = a; ////     sta    WSYNC            ; 3

//  ;---------------------------------------
  HMOVE = a; //vcs.hmove.apply = a; //     sta    HMOVE            ; 3
  nop(); //     nop                     ; 2
waitPos0:
  x--; //     dex                     ; 2
  goto waitPos0 if !negative; //     bpl    .waitPos0        ; 2³
  RESP0 = a; //vcs.reset.player1 = a; //    sta    RESP0            ; 3
  a = posLeftBranch; //     lda    posLeftBranch    ; 3
  HMP0 = a; //vcs.hmove.player1 = a; //      sta    HMP0             ; 3
  a = posRightBranch; //     lda    posRightBranch   ; 3
  HMP1 = a; //vcs.hmove.player2 = a; //     sta    HMP1             ; 3
waitPos1:
  y--; //     dey                     ; 2
  goto waitPos1 if !negative; //     bpl    .waitPos1        ; 2³
  RESP1 = a; //    sta    RESP1            ; 3
  WSYNC = a; //    sta    WSYNC            ; 3
//;---------------------------------------
  HMOVE = a; //     sta    HMOVE            ; 3
  a = 0b101; //     lda    #%101            ; 2                 enable playfield priority, now..
  CTRLPF = a; //    sta    CTRLPF           ; 3                 ..the leaves overlap the branches
  y = 31; //    ldy    #31              ; 2
  a = treePat; //    lda    treePat          ; 3
  a = a << 1; //    asl                     ; 2
  a = a << 1; //    asl                     ; 2
  x = a ; //    tax                     ; 2
//  ; Kernel 1 (31 lines): draw liana, branches and bottom of leaves:
loopBranches:
  carry = false; //    clc                     ; 2
  a = hmblSum;//     lda    hmblSum          ; 3
  a = a +#hmblSum;  //    adc    hmblAdd          ; 3
  hmblSum = a; //     sta    hmblSum          ; 3
  vcs.hmove.clear = a; //     sta    HMCLR            ; 3
  goto noMove0 if !carry;  //   bcc    .noMove0         ; 2³
  hmblDir = a; //     lda    hmblDir          ; 3
  HMBL = a; //     sta    HMBL             ; 3
noMove0:
  a = 0; //lda    #0               ; 2
  cmp(y,9); //     cpy    #9               ; 2                 draw branches in lower 9 lines
  goto noBranch if carry; //     bcs    .noBranch        ; 2³
  a = y; //     tya                     ; 2

  a = a >>> 1; //     lsr                     ; 2
  a = BranchTab[y]; //     lda    BranchTab,y      ; 4
noBranch:
  WSYNC = a; //    sta    WSYNC            ; 3
//;---------------------------------------
  HMOVE = a; //    sta    HMOVE            ; 3
  GRP0 = a; //    sta    GRP0             ; 3
  GRP1 = a; //    sta    GRP1             ; 3
  goto noChangePF if carry; //    bcs    .noChangePF      ; 2³                two line resolution for leaves
  a = PFLeavesTab[x]; //   lda    PFLeavesTab,x    ; 4                 x = 0..3
  x++; //     inx                     ; 2
  PF0 = a; //     sta    PF0              ; 3
  PF1 = a; //    sta    PF1              ; 3
  PF2 = a; //     sta    PF2              ; 3
noChangePF:
  y--; //    dey                     ; 2
  goto loopBranches if !zero; //    bne    .loopBranches    ; 2³

//  ; prepare Kernel 2: draw liana, disable branches, draw logs:
  x = treePat; //    ldx    treePat          ; 3
  carry = false; //    clc                     ; 2
  a = hmblSum; //    lda    hmblSum          ; 3
  a = a +#hmblAdd; //    adc    hmblAdd          ; 3
  hmblSum = a; //    sta    hmblSum          ; 3
  goto noMove1 if !carry; //    bcc    .noMove1         ; 2³
  y = hmblDir; //    ldy    hmblDir          ; 3
noMove1:
  HMBL = y;         //   sty    HMBL             ; 3
  a = 0b001;        //   lda    #%001            ; 2
  CTRLPF = a;       //   sta    CTRLPF           ; 3                 disable playfield priority
  a = PF1LogTab[x]; //   lda    PF1LogTab,x      ; 4
  y = PF2LogTab[x]; //   ldy    PF2LogTab,x      ; 4
  x = nusize1;      //   ldx    nusize1          ; 3
  WSYNC = a;        //   sta    WSYNC            ; 3
//;---------------------------------------
  HMOVE = a;        //   sta    HMOVE            ; 3
  PF1 = a;          //   sta    PF1              ; 3                 draw outer logs
  a = colorLst[5];  //   lda    colorLst+5       ; 3                 always BROWN-2
  COLUPF = a;       //   sta    COLUPF           ; 3
  a = 0;            //   lda    #0               ; 2
  GRP0 = a;         //   sta    GRP0             ; 3
  GRP1 = a;         //   sta    GRP1             ; 3
  NUSIZ0 = a;       //   sta    NUSIZ0           ; 3
  PF0 = a;          //   sta    PF0              ; 3
  PF2 = y;          //   sty    PF2              ; 3                 draw inner logs
  NUSIZ1 = x;       //   stx    NUSIZ1           ; 3  
//  ; Kernel 2 (4 lines): draw liana, position Harry and other object:
  x = 1; //     ldx    #1               ; 2
  carry = false;  //     clc                     ; 2
loopLianaPos:
  a = hmblSum; //   lda    hmblSum          ; 3
  a = a +#hmblAdd; //     adc    hmblAdd          ; 3
  hmblSum = a; //     sta    hmblSum          ; 3
  a = 0; //     lda    #$00             ; 2
  goto noMove2 if !carry; //     bcc    .noMove2         ; 2³
  a = hmblDir; //     lda    hmblDir          ; 3

noMove2:
  HMBL = a; // sta    HMBL             ; 3
  carry = false; //     clc                     ; 2                 precalc liana for next line
  a = hmblSum; //     lda    hmblSum          ; 3
  a = a +#hmblAdd; //    adc    hmblAdd          ; 3
  hmblSum = a; //     sta    hmblSum          ; 3
  a = 0; //     lda    #$00             ; 2
  goto noMove3 if !carry; //    bcc    .noMove3         ; 2³
  a = hmblDir; //    lda    hmblDir          ; 3

noMove3:
  WSYNC = a; //    sta    WSYNC            ; 3
//  ;---------------------------------------
  HMOVE = a; //
  y = 0; //    ldy    #0               ; 2                 do the coarse positions
  temp[x] = y;//     sty    temp1,x          ; 4
  y = HMCoarseLst[x]; //  ldy    HMCoarseLst,x    ; 4                 position at the very left?
  goto waitPos if !zero; //    bne    .waitPos         ; 2³                 no, skip
  y = 0x60; //    ldy    #$60             ; 2                  yes, use special code
  temp[x] = y;//    sty    temp1,x          ; 4
  RESP[x] = a; //    sta    RESP0,x          ; 4
  HMBL = a; //    sta    HMBL             ; 3
  goto endPos0 if !zero; //    bne    .endPos0         ; 3
waitPos:
  y--; //    dey                     ; 2                 "normal" position
  goto waitPos if !zero; //     bne    .waitPos         ; 2³
  HMBL = a; //    sta.w  HMBL             ; 4
  RESP[x] = a; //    sta    RESP0,x          ; 4
endPos0:
  a = WSYNC; //    sta    WSYNC            ; 3
//;---------------------------------------
  HMOVE = a; //    sta    HMOVE            ; 3
  x--; //    dex                     ; 2
  goto loopLianaPos if !negative; //    bpl    .loopLianaPos    ; 2³
  DrawLiana(); //    jsr    DrawLiana        ;31/33
  a = HMFineLst[0]; //    lda    HMFineLst        ; 3
  HMP0 = a; //    sta    HMP0             ; 3                 do the fine positions
  a = HMFineLst[1]; //    lda    HMFineLst+1      ; 3
  HMP1 = a; //    sta    HMP1             ; 3
  WSYNC = a; //    sta    WSYNC            ; 3
//;---------------------------------------
  HMOVE = a; //    sta    HMOVE            ; 3
  DrawLiana(); //    jsr    DrawLiana        ;31/33
  a = temp1; //    lda    temp1            ; 3
  HMP0 = a; //    sta    HMP0             ; 3
  a = temp2; //    lda    temp2            ; 3
  HMP1 = a; //    sta    HMP1             ; 3
  a = yPosHarry; //    lda    yPosHarry        ; 3                 calculate offset for Harry's pattern
  carry = false; //    clc                     ; 2
  a = a +#patOfsHarry; //    adc    patOfsHarry      ; 3
  a = a +#21;  //    adc    #21              ; 2
  y = a;   //    tay                     ; 2
  a = reflectHarry;//    lda    reflectHarry     ; 3
  REFP0 = a; //    sta    REFP0            ; 3
  WSYNC = a; //    sta    WSYNC            ; 3
//;---------------------------------------
  HMOVE = a; //    sta    HMOVE            ; 3
  CXCLR = a; //    sta    CXCLR            ; 3
  x = 20; //    ldx    #20              ; 2
  VDELP0 = x; //    stx    VDELP0           ; 3                 disable vertical delay for Harry
//; Kernel 3 (21 lines): draw liana and Harry:
loopLianaHarry:
  carry = false; //    clc                     ; 2
  a = hmblSum; //    lda    hmblSum          ; 3
  a = a +#hmblAdd; //    adc    hmblAdd          ; 3
  hmblSum = a; //    sta    hmblSum          ; 3
  a = 0; //    lda    #$00             ; 2
  HMCLR = a; //    sta    HMCLR            ; 3
  goto noMove4 if !carry; //    bcc    .noMove4         ; 2³
  a = hmblDir; //    lda    hmblDir          ; 3
noMove4:
  HMBL = a; //    sta    HMBL             ; 3
  DrawHarry(); //    jsr    DrawHarry        ;27/37
  WSYNC = a; //    sta    WSYNC            ; 3
//;---------------------------------------
  HMOVE = a; //      sta    HMOVE            ; 3
  COLUP0 = a; //    sta    COLUP0           ; 3
  x--; //    dex                     ; 2
  goto loopLianaHarry if !negative; //    bpl    .loopLianaHarry  ; 2³
  VDELP0 = x; //    stx    VDELP0           ; 3                 enable vertical delay for Harry
  x++; //    inx                     ; 2
  GRP1 = x; //    stx    GRP1             ; 3
  goto endLiana if zero; //    beq    .endLiana        ; 3
skipHarry:
  a = 0; //    lda    #0               ; 2  GRP0 = a; //    sta    GRP0             ; 3
  goto contendLiana if zero; //    beq    .contendLiana    ; 3
endLiana:
  x = 23; //    ldx    #23              ; 2
//; Kernel 4 (24 lines): draw end of liana, draw Harry:
loopEndLiana:
  carry = false; //    clc                     ; 2
  a = hmblSum; //    lda    hmblSum          ; 3
  a = a +#hmblAdd; //    adc    hmblAdd          ; 3
    hmblSum = a; //    sta    hmblSum          ; 3
  a = 0; //    lda    #$00             ; 2
  goto noMove5 if !carry; //    bcc    .noMove5         ; 2³
  a = hmblDir; //    lda    hmblDir          ; 3
noMove5:
  HMBL = a; //    sta    HMBL             ; 3
  y--; //    dey                     ; 2
  cmp(y,HARRY_H); //    cpy    #HARRY_H         ; 2
  goto skipHarry if carry;  //    bcs    .skipHarry       ; 2³
  a = harryPatPtr8[y]; //    lda    (harryPatPtr),y  ; 5
  GRP0 = a; //    sta    GRP0             ; 3
  a = harryColPtr8[y]; //    lda    (harryColPtr),y  ; 5
//  IF SCREENSAVER
  a = a ^ SS_XOR; //     eor    SS_XOR           ; 3
  a = a & SS_Mask; //     and    SS_Mask          ; 3

//  ELSE
//    FILL_NOP 4
//  ENDIF
contendLiana:
  WSYNC = a;//    sta    WSYNC            ; 3

//  ;---------------------------------------
  HMOVE = a; //    sta    HMOVE            ; 3
  COLUP0 = a; //    sta    COLUP0           ; 3
  a = DISABLE; //    lda    #DISABLE         ; 2
  cmp(x,lianaBottom); //    cpx    lianaBottom      ; 3                 bottom of liana reached?
  goto skipDisable if carry; //    bcs    .skipDisable     ; 2³                 no, skip
  ENABL = a; //    sta    ENABL            ; 3                  yes, disable liana
skipDisable:
  GRP1 = a; //    sta    GRP1             ; 3
  x--; //    dex                     ; 2
  goto loopEndLiana if !negative; //    bpl    .loopEndLiana    ; 2³
  DrawHarry(); //    jsr    DrawHarry        ;27/37
  x = CXP0FB;// - 0x30; //    ldx    CXP0FB-$30       ; 3
  hitLiana = x; //    stx    hitLiana         ; 3
  WSYNC = a; //    sta    WSYNC            ; 3
//  ;---------------------------------------
  HMOVE = a; //    sta    HMOVE            ; 3
  COLUP0 = a; //    sta    COLUP0           ; 3
  a = colorLst[7]; //    lda    colorLst+7       ; 3
  COLUPF = a; //    sta    COLUPF           ; 3
  x = 0xff; //    ldx    #$ff             ; 2                 draw the jungle ground
  PF0 = x; //    stx    PF0              ; 3
  PF1 = x; //    stx    PF1              ; 3
  PF2 = x; //    stx    PF2              ; 3
  a = colorLst[8]; //  lda    colorLst+8       ; 3
  COLUBK = a; //    sta    COLUBK           ; 3
  x++; //    inx                     ; 2
  GRP1 = x; //    stx    GRP1             ; 3
  x = 6; //    ldx    #6               ; 2
//  ; Kernel 5: draw Harry, holes, top of object on the ground:
loopGround:
  DrawHarry(); //    jsr    DrawHarry        ;27/37
  WSYNC = a; //    sta    WSYNC            ; 3
//;---------------------------------------
  HMOVE = a; //    sta    HMOVE            ; 3
  COLUP0 = a; //    sta    COLUP0           ; 3
  a = objColLst[x]; //    lda    objColLst,x      ; 4
  COLUP1 = a; //    sta    COLUP1           ; 3
  a = objPatLst[x]; //    lda    objPatLst,x      ; 4                 draw object (crocodiles, logs, snake...)
  GRP1 = a; //    sta    GRP1             ; 3
  a = PF2Lst[x]; //    lda    PF2Lst,x         ; 4                 draw pits
  PF2 = a; //    sta    PF2              ; 3
  x--;//    dex                     ; 2
  goto loopGround if !negative; //    bpl    .loopGround      ; 2³=31/32
  a = y; //    tya                     ; 2                 calculate and save..
  carry = true; //    sec                     ; 2                 ..Harry's pattern..
  a = a -#8; //    sbc    #8               ; 2                 ..offset for kernel 7
  temp1 = a; //    sta    temp1            ; 3
  x = 0;//    ldx    #0               ; 2
  y = 7; //    ldy    #7               ; 2
//  ; Kernel 6 (8 lines): draw bottom of object on the ground, holes in the ground:
loopHoles:
  a = 0;//    lda    #0               ; 2
  GRP0 = a; //    sta    GRP0             ; 3
  a = objColPtr8[y]; //    lda    (objColPtr),y    ; 5
//  IF SCREENSAVER
  a = a ^ SS_XOR; //    eor    SS_XOR           ; 3
  a = a & SS_Mask; //    and    SS_Mask          ; 3
//  ELSE
//    FILL_NOP 4
//  ENDIF
  WSYNC = a; //  sta    WSYNC            ; 3
//  ;---------------------------------------
  HMOVE = a;//    sta    HMOVE            ; 3
  COLUP1 = a; //    sta    COLUP1           ; 3
  a = objPatPtr8[y]; //    lda    (objPatPtr),y    ; 5
  GRP1 = a; //    sta    GRP1             ; 3
  y--; //    dey                     ; 2
  goto exitHoles if negative; //    bmi    .exitHoles       ; 2³                exit loop here
  a = PF2Lst[x]; //    lda    PF2Lst,x         ; 4
  PF2 = a; //    sta    PF2              ; 3
  x++; //    inx                     ; 2
  goto loopHoles if !zero; //    bne    .loopHoles       ; 3                 loop always
exitHoles:
  a = 0; //    lda    #0               ; 2
  GRP0 = a; //    sta    GRP0             ; 3                 clear Harry again (JTZ: superfluous)
  x = HMCoarseLst[2];  //    ldx    HMCoarseLst+2    ; 3
  goto notZero if !zero; //    bne    .notZero         ; 2³
  a = 0x60; //    lda    #$60             ; 2                 special HMOV when scorpion is at the very left
notZero:
  temp3 = a; //    sta    temp3            ; 3 
//check Harry's collisions (JTZ: superfluous code!)
  a = CXPPMM;//     lda    CXPPMM-$30       ; 3                 Harry collided with other objects?
  a = a << 1; //    asl                     ; 2
  a = CXP0FB; //    lda    CXP0FB-$30       ; 3                 Harry collided with playfield?
  a = a >>>># 1; //    ror                     ; 2
  cxHarry = a; //    sta    cxHarry          ; 3                 store here (this variable isn't used somewhere else!)
//; prepare some underground data:
  a = reflectScorpion; //    lda    reflectScorpion  ; 3                 set player 1 reflection
  REFP1 = a; //    sta    REFP1            ; 3
  a = ladderFlag; //    lda    ladderFlag       ; 3                 calculate playfield reflection
  a = a & 0b000100; //    and    #%000100         ; 2
  a = a ^ 0b100101; //    eor    #%100101         ; 2                 ball is 4 clocks wide (ladder)
  x = a; //    tax                     ; 2
  y = colorLst[6]; //    ldy    colorLst+6       ; 3                 underground color (always BROWN+2)
  a = colorLst[4]; //    lda    colorLst+4       ; 3                 hole, blackground and tar pit color
  WSYNC = a; //    sta    WSYNC            ; 3
//;---------------------------------------
  HMOVE = a; //    sta    HMOVE            ; 3
  goto ContKernel; //    jmp    ContKernel       ; 3

//goto MainLoop;
  
//  nop();
//  nop();
//  nop();
//  nop();

    
#[fallthrough] func ShowDigits() {
  //SUBROUTINE
  WSYNC = a; //     sta    WSYNC            ; 3
  a = colorLst[0]; //     lda    colorLst         ; 3
  COLUP0 = a; //vcs.color.player1 = a; //     sta    COLUP0           ; 3
  COLUP1 = a; //vcs.color.player2 = a; //     sta    COLUP1           ; 3
  y = 0;  //    ldy    #0               ; 2
  REFP0 = y; //     sty    REFP0            ; 3
  REFP1 = y; //     sty    REFP1            ; 3
  x = 10 | THREE_COPIES; //     ldx    #$10|THREE_COPIES; 2
  NUSIZ0 = x; //     stx    NUSIZ0           ; 3
  RESP0 = a; //     sta    RESP0            ; 3
  RESP1 = a; //     sta    RESP1            ; 3
  HMP1 = x; //     stx    HMP1             ; 3
  WSYNC = a; //     sta    WSYNC            ; 3
  HMOVE = a;  //   sta    HMOVE            ; 3
  NUSIZ0 = x; //     stx    NUSIZ0           ; 3
  y++; //     iny                     ; 2
  CTRLPF = y; //     sty    CTRLPF           ; 3                 enable playfield reflection
  a = DIGIT_H - 1; //     lda    #DIGIT_H-1       ; 2
  VDELP0 = a; //     sta    VDELP0           ; 3
  VDELP1 = a; //     sta    VDELP1           ; 3
  temp2 = a; //     sta    temp2            ; 3
  HMCLR = a; //     sta    HMCLR            ; 3
  SkipIny(); //     jsr    SkipIny          ;22                 just waste 22 cycles
  a = temp3; //     lda    temp3            ; 3                 just waste three cycles
loopDigits:
  
  /*
;---------------------------------------
;---------------------------------------
.loopDigits:
*/
  y = temp2; //     ldy    temp2            ; 3
  a = (digitPtr10a as *u8)[y]; //     lda    (digitPtr+10),y  ; 5
//  a = (*digitPtr)+2[y];// as *u8 /* + 10 */)[y]; //     lda    (digitPtr+10),y  ; 5
  temp1 = a; //     sta    temp1            ; 3
  a = (digitPtr8a as *u8)[y]; //     lda    (digitPtr+8),y   ; 5
  x = a; //     tax                     ; 2
  a = (digitPtra as *u8)[y]; //     lda    (digitPtr),y     ; 5
  a = a | temp3; //     ora    temp3            ; 3                 show lives when drawing time
  vcs.hmove.apply = a;  //    sta    HMOVE            ; 3                 produce HMOVE blanks
  vcs.pattern.player1 = a; //     sta    GRP0             ; 3
  a = (digitPtr2a as *u8 /* +2 */)[y]; //     lda    (digitPtr+2),y   ; 5
  vcs.pattern.player2 = a; //     sta    GRP1             ; 3
  a = (digitPtr4a as *u8 /* + 4 */)[y]; //     lda    (digitPtr+4),y   ; 5
  vcs.pattern.player1 = a; //     sta    GRP0             ; 3
  a = (digitPtr6a as *u8 /* + 6 */)[y]; //    lda    (digitPtr+6),y   ; 5
  y = temp1; //     ldy    temp1            ; 3
  vcs.pattern.player2 = a; //     sta    GRP1             ; 3
  vcs.pattern.player1 = x; //     stx    GRP0             ; 3
  vcs.pattern.player2 = y; //     sty    GRP1             ; 3
  vcs.pattern.player2 = a; //     sta    GRP0             ; 3
  temp2--; //     dec    temp2            ; 5
  goto loopDigits if !negative; //     bpl    .loopDigits      ; 2³

  /*
;---------------------------------------
*/
  WSYNC = a; //     sta    WSYNC            ; 3
  HMOVE = a; //     sta    HMOVE            ; 3
  a = 0; //     lda    #0               ; 2
  vcs.pattern.player1 = a; //     sta    GRP0             ; 3
  vcs.pattern.player2 = a; //     sta    GRP1             ; 3
  vcs.pattern.player1 = a; //     sta    GRP0             ; 3
  //  rts                     ; 6
  return;
}
  
#[fallthrough]  func DrawHarry() {
  y--; //        dey                     ; 2
  cmp(y,HARRY_H); //    cpy    #HARRY_H         ; 2
  goto skipDraw if carry; //    bcs    .skipDraw        ; 2³
  a = (harryPatPtr as *u8)[y]; //    lda    (harryPatPtr),y  ; 5
  GRP0 = a; //    sta    GRP0             ; 3
  a = (harryColPtr as *u8)[y]; //    lda    (harryColPtr),y  ; 5
  a = a ^ SS_XOR;
  a = a & SS_Mask;
    /*
  IF SCREENSAVER
    eor    SS_XOR           ; 3
    and    SS_Mask          ; 3
  ELSE
    FILL_NOP 3
  ENDIF
  */
}
exitDraw:
    return; //    rts                     ; 6 = 21/31
/*
  IF SCREENSAVER = 0
; do some missing nops:
    FILL_NOP 2
  ENDIF
*/
//  }
skipDraw:
  a = 0;//    lda    #0               ; 2
  GRP0 = a; //  sta    GRP0             ; 3
  goto exitDraw if zero;//    beq    .exitDraw        ; 3
#[fallthrough]  func CalcPosX() {
//  ; calculate coarse and fine x-positioning values:
  y = a;         //    tay                     ; 2
  y++;           //    iny                     ; 2
  a = y;         //    tya                     ; 2
  a = a & 0x0f;  //    and    #$0f             ; 2
  temp1 = a;     //    sta    temp1            ; 3
  a = y;         //    tya                     ; 2
  a = a >>> 1;   //    lsr                     ; 2
  a = a >>> 1;   //    lsr                     ; 2
  a = a >>> 1;   //    lsr                     ; 2
  a = a >>> 1;   //    lsr                     ; 2
  y = a;         //    tay                     ; 2
  carry = false; //    clc                     ; 2
  a = a +#temp1; //    adc    temp1            ; 3
  cmp(a,0x0f);   //    cmp    #$0f             ; 2
  goto SkipIny if !carry; //     bcc    SkipIny         ; 2³
  a = a -#0x0f;  //    sbc    #$0f             ; 2
  y++;           //    iny                     ; 2
  }

#[fallthrough] func SkipIny () {

    a = a ^ 0x07; // eor    #$07             ; 2    
    a = a << 1; //     asl                     ; 2
    a = a << 1; //     asl                     ; 2
    a = a << 1; //     asl                     ; 2
    a = a << 1; //     asl                     ; 2
    //    rts                     ; 6
    return;
  }

#[fallthrough]   func DrawLiana() {
//    DrawLiana SUBROUTINE
    carry = false;   //    clc                     ; 2
    a = hmblSum;     //    lda    hmblSum          ; 3
    a = a +#hmblAdd; //    adc    hmblAdd          ; 3
    hmblSum = a;     //    sta    hmblSum          ; 3
    a = 0x00;        //    lda    #$00             ; 2
    goto noMove6 if !carry; //    bcc    .noMove6         ; 2³
    a = hmblDir;     //    lda    hmblDir          ; 3
noMove6:
    HMBL = a;        //    sta    HMBL             ; 3
  return;
//    rts                     ; 6 = 25/27
  }
 
#[fallthrough]   func BCD2DigitPtrs() {
    //SUBROUTINE
    a = scoreHi8[x];  //     lda    scoreHi,x        ; 4
    a = a & 0xf0;     //     and    #$f0             ; 2
    a = a >>> 1;      //     lsr                     ; 2
    digitPtr[y] = a;  //     sta    digitPtr,y       ; 5
    a = scoreHi8[x];  //     lda    scoreHi,x        ; 4
    a = a & 0x0f;     //     and    #$0f             ; 2
    a = a << 1;       //     asl                     ; 2
    a = a << 1;       //     asl                     ; 2
    a = a << 1;       //     asl                     ; 2
    digitPtr2[y] = a; //     sta    digitPtr+2,y     ; 5
    WSYNC = a;        //     sta    WSYNC            ; 3
    HMOVE = a;        //     sta    HMOVE            ; 3
    return;           //     rts                     ; 6
  }
#[fallthrough]  func DecScoreLo() {
   //SUBROUTINE
   a = 7; //    lda    #$07             ; 2
   AUDC1 = a; //    sta    AUDC1            ; 3
   a = 0x99; //    lda    #$99             ; 2              decrease scoreLo by 1
}
#[fallthrough] func DecScoreHi() {  //               ;                decrease scoreHi by 1
   decimal = true; //    sed                     ; 2
   carry = false; //    clc                     ; 2
   a = a +#scoreLo; //    adc    scoreLo          ; 3
     scoreLo = a; //    sta    scoreLo          ; 3
   a = scoreMed; // lda    scoreMed         ; 3
   a = a -#0x00; //    sbc    #$00             ; 2
   scoreMed = a; //    sta    scoreMed         ; 3
   a = scoreHi; //    lda    scoreHi          ; 3
   a = a -#0x00; //    sbc    #$00             ; 2
   goto notZero if carry; //    bcs    .notZero         ; 2³
   a = 0x00; //    lda    #$00             ; 2             limit score at zero
   scoreMed = a; //    sta    scoreMed         ; 3
   scoreLo = a; // sta    scoreLo          ; 3
notZero:
   scoreHi = a; //    sta    scoreHi          ; 3
   decimal = false; //    cld                     ; 2
   return; // rts                     ; 6
   }
  

  const PFLeavesTab : [u8] = [ 
    0b11111111, // ; |XXXXXXXX|
    0b11001111, // ; |XX  XXXX|
    0b10000011, // ; |X     XX|
    0b00000001, // ; |       X|

    0b01111111, // ; | XXXXXXX|
    0b00111101, // ; |  XXXX X|
    0b00011000, // ; |   XX   |
    0b00000000, // ; |        |

    0b11111111, // ; |XXXXXXXX|
    0b11111110, // ; |XXXXXXX |
    0b10111100, // ; |X XXXX  |
    0b00011000, // ; |   XX   |

    0b11111110, // ; |XXXXXXX |
    0b11111100, // ; |XXXXXX  |
    0b01111000, // ; | XXXX   |
    0b00110000, // ; |  XX    |
 ];
 
Kernel2:
   //SUBROUTINE
skipHarry1:
  a = 0; // lda    #0               ; 2
    
  GRP0 = a; //    sta    GRP0             ; 3
  goto conrHarry if zero; //    beq    .conrHarry       ; 3

ContKernel:
  COLUBK = a; //    sta    COLUBK           ; 3
  COLUPF = y; //   sty    COLUPF           ; 3
    a = 0; //    lda    #0               ; 2
  GRP1 = a; //    sta    GRP1             ; 3
  a = 0xff; //    lda    #$ff             ; 2
  PF1 = a; //    sta    PF1              ; 3
  a = PF2QuickSand; //    lda    PF2QuickSand     ; 3
  PF2 = a; //    sta    PF2              ; 3
  CTRLPF = x; //    stx    CTRLPF           ; 3
  y = temp1; //    ldy    temp1            ; 3
  a = 0x90; //    lda    #$90             ; 2
  HMBL = a; //    sta.w  HMBL             ; 4
  cmp(y,HARRY_H); //    cpy    #HARRY_H         ; 2
  RESBL = a; //    sta    RESBL            ; 3
  goto skipHarry1 if carry; //    bcs    .skipHarry1      ; 2³+1
  a = (harryPatPtr as *u8)[y]; //    lda    (harryPatPtr),y  ; 5
  GRP0 = a; //    sta    GRP0             ; 3
  a = (harryColPtr as *u8)[y]; //    lda    (harryColPtr),y  ; 5
  
//  IF SCREENSAVER
  a = a ^ SS_XOR; //    eor    SS_XOR           ; 3
  a = a & SS_Mask; //    and    SS_Mask          ; 3
//  ELSE
//    FILL_NOP 4
//  ENDIF
conrHarry:
  x = HMCoarseLst[2]; //    ldx    HMCoarseLst+2    ; 3
  WSYNC = a; //    sta    WSYNC            ; 3
//  ;---------------------------------------
  HMOVE = a; //    sta    HMOVE            ; 3
  COLUP0 = a; //    sta    COLUP0           ; 3
 // goto wait1 if zero; //    beq    .wait1           ; 2³
  a = 1;
wait1:
//  goto wait2 if zero; //    beq    .wait2           ; 2³
  a = 2;
wait2:
  a = 0; //    lda    #0               ; 2
  GRP1 = a; //    sta    GRP1             ; 3
loopWait:
  x--; //    dex                     ; 2
  goto loopWait if !negative; //    bpl    .loopWait        ; 2³
  RESP1 = a; //    sta.w  RESP1            ; 4
  HMCLR = a; //    sta    HMCLR            ; 3
  WSYNC = a; //    sta    WSYNC            ; 3

  //;---------------------------------------
  HMOVE = a; //   sta    HMOVE            ; 3
  y--;       //   dey                     ; 2
  cmp(y,HARRY_H); //     cpy    #HARRY_H         ; 2
  goto skipHarry2 if carry; //    bcs    .skipHarry2      ; 2³
  a = (harryColPtr as *u8)[y]; //     lda    (harryColPtr),y  ; 5

  a = a ^ SS_XOR;
  a = a & SS_Mask;
/*
  IF SCREENSAVER
    eor    SS_XOR           ; 3
    and    SS_Mask          ; 3
  ELSE
    FILL_NOP 3
  ENDIF
*/
  COLUP0 = a; //  sta    COLUP0           ; 3
  a = (harryPatPtr as *u8)[y]; //    lda    (harryPatPtr),y  ; 5
  GRP0 = a; //    sta    GRP0             ; 3
skipHarry2:
  a = 0;    //    lda    #0               ; 2
  GRP1 = a; //    sta    GRP1             ; 3
  a = HMFineLst[2]; //    lda    HMFineLst+2      ; 3
  HMP1 = a; //    sta    HMP1             ; 3                 position scorpion or wall
  x = 11; //    ldx    #11              ; 2
  y--; //    dey                     ; 2

//  ; Kernel 7 (12 lines): draw top of ladder, draw Harry:
loopLadderTop:
  y--;//    dey                     ; 2
  cmp(y,HARRY_H); //    cpy    #HARRY_H         ; 2
  goto skipHarry3 if carry;//    bcs    .skipHarry3      ; 2³
  a = (harryPatPtr as *u8)[y]; //    lda    (harryPatPtr),y  ; 5
  GRP0 = a; //    sta    GRP0             ; 3
  a = (harryColPtr as *u8)[y]; //    lda    (harryColPtr),y  ; 5
  a = a ^ SS_XOR;
  a = a & SS_Mask;

/*  IF SCREENSAVER
    eor    SS_XOR           ; 3
    and    SS_Mask          ; 3
  ELSE
    FILL_NOP 4
  ENDIF
  */
contHarry3:
  WSYNC = a; //    sta    WSYNC            ; 3
//  ;---------------------------------------
  HMOVE = a; //    sta    HMOVE            ; 3
  COLUP0 = a; //    sta    COLUP0           ; 3
  a = 0; //    lda    #0               ; 2
  GRP1 = a; //    sta    GRP1             ; 3
  a = LadderTab[x]; //    lda    LadderTab,x      ; 4
  a = a & ladderFlag; //    and    ladderFlag       ; 3
  ENABL = a; //    sta    ENABL            ; 3
  x--; //    dex                     ; 2
  goto exitLadderTop if negative; //    bmi    .exitLadderTop   ; 2³                exit loop
  a = temp3; //    lda    temp3            ; 3
  HMCLR = a; //    sta    HMCLR            ; 3
  HMP1 = a; //    sta    HMP1             ; 3                 position scorpion at the very left
  a = 15; //  lda    #15              ; 2                 clear hmove value, prepare height of a later loop
  temp3 = a; //    sta    temp3            ; 3
  goto loopLadderTop if !zero; //    bne    .loopLadderTop   ; 3                 loop always

skipHarry3:
  a = 0; //    lda    #0               ; 2
  GRP0 = a; //    sta    GRP0             ; 3
  goto contHarry3 if zero; //    beq    .contHarry3      ; 3

skipHarry4:
  a = 0; //    lda    #0               ; 2
  GRP0 = a; //    sta    GRP0             ; 3
  goto contHarry4 if zero; //    beq    .contHarry4      ; 3
  
exitLadderTop:
  y--; //    dey                     ; 2
  temp1 = y; //    sty    temp1            ; 3
  cmp(y, HARRY_H); //    cpy    #HARRY_H         ; 2
  goto skipHarry4 if carry; //    bcs    .skipHarry4      ; 2³
  a = (harryPatPtr as *u8)[y]; //    lda    (harryPatPtr),y  ; 5
  GRP0 = a; //    sta    GRP0             ; 3
  a = (harryColPtr as *u8)[y]; //    lda    (harryColPtr),y  ; 5
  a = a ^ SS_XOR;
  a = a & SS_Mask;
/*
  IF SCREENSAVER
    eor    SS_XOR           ; 3
    and    SS_Mask          ; 3
  ELSE
    FILL_NOP 4
  ENDIF
  */
contHarry4:
  y = 15; //    ldy    #15              ; 2
  temp2 = a; //    sta    temp2            ; 3
  a = (wallPatPtr as *u8)[y]; //    lda    (wallPatPtr),y   ; 5
  x = ONE_COPY; //    ldx    #ONE_COPY        ; 2                 = 0
  NUSIZ1 = x; //    stx    NUSIZ1           ; 3
  WSYNC = a; //    sta    WSYNC            ; 3
  
//;---------------------------------------
  HMOVE = a; //    sta    HMOVE            ; 3
  GRP1 = a; //    sta    GRP1             ; 3
  a = temp2; //    lda    temp2            ; 3
  COLUP0 = a; //    sta    COLUP0           ; 3
  PF0 = x; //    stx    PF0              ; 3                 clear playfield
  a = DARK_RED; //    lda    #DARK_RED        ; 2                 wall color
  a = a & SS_Mask; 
  /*
  IF SCREENSAVER
    and    SS_Mask          ; 3
  ELSE
    FILL_NOP 2
  ENDIF
  */
  COLUP1 = a; //    sta    COLUP1           ; 3
  PF1 = x; //    stx    PF1              ; 3
  PF2 = x; //    stx    PF2              ; 3
  a = ladderFlag; //    lda    ladderFlag       ; 3
  ENABL = a; //    sta    ENABL            ; 3
  y--; //    dey                     ; 2
  temp2 = y; //    sty    temp2            ; 3
  x = temp1;//    ldx    temp1            ; 3
//; Kernel 8 (15 lines): draw Harry, ladder and wall:
loopLadder:
  x--; //    dex                     ; 2
  a = x; //    txa                     ; 2
  y = a; //     tay                     ; 2
  cmp(y,HARRY_H); //    cpy    #HARRY_H         ; 2
  goto skipHarry5 if carry; //    bcs    .skipHarry5      ; 2³+1
  a = (harryPatPtr as *u8)[y]; //    lda    (harryPatPtr),y  ; 5
  GRP0 = a; //    sta    GRP0             ; 3
  a = (harryColPtr as *u8)[y]; //    lda    (harryColPtr),y  ; 5
contHarry5:  
  a = a ^ SS_XOR;
  a = a & SS_Mask;

/*  IF SCREENSAVER
    eor    SS_XOR           ; 3
    and    SS_Mask          ; 3
  ELSE
    bit    $00
    bit    $00
  ENDIF
  */
  y = temp2; //    ldy    temp2            ; 3
  HMOVE = a; //    sta    HMOVE            ; 3
  COLUP0 = a; //     sta    COLUP0           ; 3
  a = (wallPatPtr as *u8)[y]; //    lda    (wallPatPtr),y   ; 5
  GRP1 = a; //    sta    GRP1             ; 3
  a = (wallColPtr as *u8)[y]; //    lda    (wallColPtr),y   ; 5
//  a = a & SS_Mask;
/*  IF SCREENSAVER
    and    SS_Mask          ; 3
  ELSE
    bit    $00
  ENDIF
  */
  COLUP1 = a; //    sta    COLUP1           ; 3
  a = LadderTab[y]; //    lda    LadderTab,y      ; 4
  a = a & ladderFlag; //    and    ladderFlag       ; 3
  ENABL = a; //    sta    ENABL            ; 3
  temp2--; //    dec    temp2            ; 5
  goto loopLadder if !negative; //    bpl    .loopLadder      ; 2³+1
  nop(); //    nop                     ; 2
  
//; Kernel 9 (16 lines): draw Harry, scorpion or the bottom of wall and ladder:
loopUnderground:
  x--; //    dex                     ; 2
  a = x; //    txa                     ; 2
  y = a; //    tay                     ; 2
  cmp(y,HARRY_H); //    cpy    #HARRY_H         ; 2
  goto skipHarry6 if carry; //    bcs    .skipHarry6      ; 2³
  a = (harryPatPtr as *u8)[y]; //    lda    (harryPatPtr),y  ; 5
  GRP0 = a; //    sta    GRP0             ; 3
  a = (harryColPtr as *u8)[y]; //    lda    (harryColPtr),y  ; 5
contHarry6:
  a = a ^ SS_XOR;
  a = a & SS_Mask;

/*  IF SCREENSAVER
    eor    SS_XOR           ; 3
    and    SS_Mask          ; 3
  ELSE
    bit    $00
    bit    $00
  ENDIF
  */
  y = temp3;
//    ldy    temp3            ; 3
  HMOVE = a; //    sta    HMOVE            ; 3
  COLUP0 = a; //    sta    COLUP0           ; 3
  a = (undrPatPtr as *u8)[y]; //    lda    (undrPatPtr),y   ; 5
  GRP1 = a; //    sta    GRP1             ; 3
  a = (undrColPtr as *u8)[y]; //    lda    (undrColPtr),y   ; 5
  a = a & SS_Mask;

/*  IF SCREENSAVER
    and    SS_Mask          ; 3
  ELSE
    bit    $00
  ENDIF
  */
  COLUP1 = a; //    sta    COLUP1           ; 3
  a = LadderTab[y]; //    lda    LadderTab,y      ; 4
  a = a & ladderFlag; //    and    ladderFlag       ; 3
  ENABL = a; //    sta.w  ENABL            ; 4
  temp3--; //    dec    temp3            ; 5
  goto loopUnderground if !negative; //    bpl    .loopUnderground ; 2³
  goto exitKernel if negative; //    bmi    .exitKernel      ; 3
  
skipHarry5:
  a = 0; //   lda    #0               ; 2
  GRP0 = a; //     sta    GRP0             ; 3
  nop(); //    nop                     ; 2
  goto contHarry5 if zero; //     beq    .contHarry5      ; 4                 page crossed!


skipHarry6:
  a = 0; //    lda    #0               ; 2
  GRP0 = a; //    sta    GRP0             ; 3
  nop(); //    nop                     ; 2
  nop(); //    nop                     ; 2
  goto contHarry6 if zero; //    beq    .contHarry6      ; 3

exitKernel:
  x = 0xff; //    ldx    #$ff             ; 2
  WSYNC = a; //    sta    WSYNC            ; 3  
  HMOVE = a; //     sta    HMOVE            ; 3
  PF0 = x; //    stx    PF0              ; 3                 fill playfield registers
  PF1 = x; //    stx    PF1              ; 3
  PF2 = x; //    stx    PF2              ; 3
  x++; //    inx                     ; 2                 x = 0
  ENABL = x; //    stx    ENABL            ; 3                 clear ball and graphics registers
  GRP0 = x; //     stx    GRP0             ; 3
  GRP1 = x; //     stx    GRP1             ; 3
  GRP0 = x; //     stx    GRP0             ; 3

//  ; show animated copyright:
  temp3 = x; //    stx    temp3            ; 3                 show nothing before copyright
  y = COPYRIGHT_H / 2; //    ldy    #COPYRIGHT_H/2   ; 2
  a = noGameScroll; //    lda    noGameScroll     ; 3
  x = soundIdx; //    ldx    soundIdx         ; 3
  goto noSound0 if zero; //    beq    .noSound0        ; 2³
  a = 0; //    lda    #0               ; 2
noSound0:
  a = a >>> 1; //    lsr                     ; 2
  a = a >>> 1; //    lsr                     ; 2
  a = a >>> 1; //    lsr                     ; 2
  cmp(a,20); //    cmp    #20              ; 2                 scroll-animation
  goto ok if carry; //    bcs    .ok              ; 2³
  y = 0; //    ldy    #0               ; 2
  cmp(a,12); //    cmp    #12              ; 2
  goto ok if !carry; //  bcc    .ok              ; 2³
  a = a -#12; //  sbc    #12              ; 2
  y = a; //    tay                     ; 2
ok:
  a = y; //    tya                     ; 2
  carry = false; //    clc                     ; 2
//  a = a +# (<:(&CopyRight5) - (COPYRIGHT_H / 2)); //    adc    #<CopyRight5-COPYRIGHT_H/2; 2
  x = 10; //    ldx    #12-2            ; 2
loopCopyright:
  WSYNC = a; //    sta    WSYNC            ; 3
  HMOVE = a; //  sta    HMOVE            ; 3
  digitPtr[x] = a; //  sta    digitPtr,x       ; 4
  carry = true;  // sec                     ; 2
  a = a -#COPYRIGHT_H; //  sbc    #COPYRIGHT_H     ; 2
  x--; //  dex                     ; 2
  x--; //  dex                     ; 2
  goto loopCopyright if !negative; //  bpl    .loopCopyright   ; 2³

  a = colorLst[4]; //      lda    colorLst+4       ; 3
  COLUPF = a; //    sta    COLUPF           ; 3
  ShowDigits(); //  jsr    ShowDigits       ; 6
  a = noGameScroll; //    lda    noGameScroll     ; 3                 game running?
  goto endCopyright if !zero; //  beq    .endCopyright    ; 2³                 yes, no more scrolling
  noGameScroll--; //  dec    noGameScroll     ; 5                  no, scoll message
  goto endCopyright if !zero; //  bne    .endCopyright    ; 2³
  noGameScroll --; //  dec    noGameScroll     ; 5                 avoid #0
endCopyright:
//  IF NTSC
#[compile_if(NTSC)] a = 32; //    lda    #32              ; 2
//  ELSE
#[compile_if(!NTSC)] a = 60; //     lda    #60
//  ENDIF
  x = 0b10000010; //    ldx    #%10000010       ; 2
  WSYNC = a; //    sta    WSYNC            ; 3
  TIM64T = a; //     sta    TIM64T           ; 4
  VBLANK = x; //     stx    VBLANK           ; 3  

//  ; check for killed Harry:
  a = soundIdx; //    lda    soundIdx         ; 3
  cmp(a,SOUND_FALLING - 1) ; //    cmp    #SOUND_FALLING-1 ; 2                 dead tune at end of playing?
  goto slipDecrease if !zero; //    bne    .slipDecrease    ; 2³                 no, skip decrease
//; Harry is loosing a life:
  a = livesPat; //  lda    livesPat         ; 3                 any more lives?
  goto slipDecrease if zero; //    beq    .slipDecrease    ; 2³                 no, skip decrease
//  IF TRAINER
//    FILL_NOP 4
//  ELSE
  a = a << 1; //    asl                     ; 2                  yes, decrease lives
  a = a << 1; //    asl                     ; 2                  yes, decrease lives
  livesPat = a; //    sta    livesPat         ; 3
//  ENDIF
  a = NOREFLECT; //  lda    #NOREFLECT       ; 2
  reflectHarry = a; //    sta    reflectHarry     ; 3
  noGameScroll = a; //    sta    noGameScroll     ; 3
  CXCLR = a; //    sta    CXCLR            ; 3
  y = 0xd0 | NO_MOVE; //    ldy    #$d0|NO_MOVE     ; 2                 upper Harry restart y-position
  oldJoystick = y; //    sty    oldJoystick      ; 3                 clear joystick
  a = 20; //    lda    #20              ; 2
  xPosHarry = a; //    sta    xPosHarry        ; 3
  x = JUMP_LEN; //    ldx    #JUMP_LEN        ; 2
  a = yPosHarry; //    lda    yPosHarry        ; 3
  cmp(a,71); //    cmp    #71              ; 2                 Harry at underground?
  goto LF5D2 if !carry;//    bcc    LF5D2            ; 2³                 no, skip
  y = 64; //    ldy    #64              ; 2                  yes, lower Harry restart y-position
  a = SCREENWIDTH / 2 - 4; //    lda    #SCREENWIDTH/2-4 ; 2                 position scorpion at center..
  xPosScorpion = a; //    sta    xPosScorpion     ; 3                 ..when Harry restarts at underground
LF5D2:
  jumpIndex = x;//    stx    jumpIndex        ; 3
  yPosHarry = y; //    sty    yPosHarry        ; 3
slipDecrease:
//  ; *** sound routines: ***
  y = 0; //    ldy    #0               ; 2
  x = soundIdx; //    ldx    soundIdx         ; 3
  goto noSound if zero; //    beq    .noSound         ; 2³
  soundDelay++; //  inc    soundDelay       ; 5
  a = soundDelay; //    lda    soundDelay       ; 3
  a = a & 0x03; //    and    #$03             ; 2                 next note every 4th frame
  goto skipNext if !zero; //    bne    .skipNext        ; 2³
  soundIdx++; //    inc    soundIdx         ; 5                 play next note
skipNext:
    a = SoundTab[x]; //    lda    SoundTab-1,x     ; 4
  goto contSound if !negative; //    bpl    .contSound       ; 2³
  soundIdx = y; //    sty    soundIdx         ; 3                 stop current sound
contSound:
  AUDF0 = a; //    sta    AUDF0            ; 3
  y = 1; //    ldy    #1               ; 2
noSound:
  AUDC0 = y; //    sty    AUDC0            ; 3
  a = 4; //    lda    #4               ; 2
  AUDV0 = a; //    sta    AUDV0            ; 3

//; check if Harry has fallen into a hole or pit:
  a = climbPos; //    lda    climbPos         ; 3                 Harry at ladder?
  goto exitBounds if !zero; //    bne    .exitBounds      ; 2³+1               yes, skip bounds check
  a = yPosHarry; //    lda    yPosHarry        ; 3
  cmp(a,JUNGLE_GROUND); //    cmp    #JUNGLE_GROUND   ; 2                 Harry at ground?
  goto exitBounds if !zero;//    bne    .exitBounds      ; 2³                 no, skip bounds check
  x = sceneType; //    ldx    sceneType        ; 3
  cmp(x,CROCO_SCENE); //  cpx    #CROCO_SCENE     ; 2                 croco scene?
  goto noCroco1 if !zero; //    bne    .noCroco1        ; 2³                 no, skip
  bit(frameCnt); //    bit    frameCnt         ; 3                 open croco jaws?
  goto contCroco if !negative; //    bpl    .contCroco       ; 2³                 yes, skip
  x--; //     dex                     ; 2                  no, use other values
  goto contCroco if !zero; //  bne    .contCroco       ; 3

noCroco1:
  cmp(x,HOLE3_SCENE + 2); //    cpx    #HOLE3_SCENE+2   ; 2                 scene with hole(s) or ???? ?
  goto contCroco if !carry; //  bcc    .contCroco       ; 2³                 yes, skip
  x = HOLE3_SCENE + 1; //    ldx    #HOLE3_SCENE+1   ; 2                  no, limit scene type
contCroco:
  a = x; //    txa                     ; 2
  a = a << 1; //    asl                     ; 2
  a = a << 1; //    asl                     ; 2
  a = a << 1; //    asl                     ; 2
  x = a; //    tax                     ; 2
  y = 3; //      ldy    #3               ; 2                 check up to 4 bounds
loopBounds:
  a = HoleBoundsTab[x]; //    lda    HoleBoundsTab,x  ; 4
  goto exitBounds if zero;//    beq    .exitBounds      ; 2³                no more bounds!
  carry = false; //    clc                     ; 2
  a = a +#xPosQuickSand; //    adc    xPosQuickSand    ; 3
  cmp(a,xPosHarry); //    cmp    xPosHarry        ; 3                 Harry left of hole/pit?
  goto inBounds if carry; //    bcs    .inBounds        ; 2³                 yes, bound ok
  a = (&HoleBoundsTab1 as *u8)[x]; //    lda    HoleBoundsTab+1,x; 4
  carry = true;//sec                     ; 2
  a = a -#xPosQuickSand; //  sbc    xPosQuickSand    ; 3
  cmp(a,xPosHarry); //    cmp    xPosHarry        ; 3                 Harry right of hole/pit?
  goto outOfBounds if carry; //    bcs    .outOfBounds     ; 2³                 no, Harry is falling into
inBounds:
  x++; //    inx                     ; 2
  x++; //     inx                     ; 2
  y--; //    dey                     ; 2
  goto loopBounds if !negative; //    bpl    .loopBounds      ; 2³
  goto exitBounds if negative; //    bmi    .exitBounds      ; 3
outOfBounds:
  yPosHarry++; //    inc    yPosHarry        ; 5                 Harry is falling down
  x = JUMP_LEN; //    ldx    #JUMP_LEN        ; 2
  jumpIndex = x; //    stx    jumpIndex        ; 3
  x--; //    dex                     ; 2
  oldJoystick = x; //    stx    oldJoystick      ; 3                 x=$1f -> no direction
exitBounds:
  a = jumpMode; //    lda    jumpMode         ; 3                 JTZ: superfluous code?
  goto waitTim if !zero; //    bne    .waitTim         ; 2³
  bit(hitLiana); //  bit    hitLiana         ; 3                 collison with liana
  goto waitTim if !overflow; //    bvc    .waitTim         ; 2³                 no, skip
  a = jumpIndex; //    lda    jumpIndex        ; 3                 currently jumping?
  goto waitTim if zero; //    beq    .waitTim         ; 2³                 no, skip
  x = atLiana; //    ldx    atLiana          ; 3                 Harry already at liana?
  goto waitTim if !zero; //    bne    .waitTim         ; 2³                 yes, skip
  jumpIndex = x; //    stx    jumpIndex        ; 3                  no, stop jump
  x++; //  inx                     ; 2
  atLiana = x; //  stx    atLiana          ; 3                 enter "liana mode"
  soundIdx = x; //    stx    soundIdx         ; 3                 start tarzan sound (=0)
//; wait for end of vertical blank:
waitTim:
  a = INTIM; //    lda    INTIM            ; 4
  goto waitTim if !zero; //    bne    .waitTim         ; 2³

//; start vertical sync:
  a = AUDC1; //    sta    AUDC1            ; 3
  y = 0b10000010;//    ldy    #%10000010       ; 2                 enable vertical sync and dump ports (JTZ: why?)
  WSYNC = y; //    sty    WSYNC            ; 3
  WSYNC = y; //    sty    WSYNC            ; 3
  WSYNC = y; //    sty    WSYNC            ; 3
  WSYNC = y; //    sty    WSYNC            ; 3
  WSYNC = y; //    sty    WSYNC            ; 3
  WSYNC = a; //    sta    VSYNC            ; 3

  
//  IF SCREENSAVER
//; process screensaver code:
  SS_DelayLo++; //    inc    SS_DelayLo       ; 5
  goto skipSS_Delay if !zero; //    bne    .skipSS_Delay    ; 2³
  SS_Delay++; //    inc    SS_Delay         ; 5
  goto skipSS_Delay if !zero; //    bne    .skipSS_Delay    ; 2³
  carry = true; //    sec                     ; 2
  SS_Delay = SS_Delay >>>># 1; //    ror    SS_Delay         ; 5
skipSS_Delay:
  y = 0xff; //    ldy    #$ff             ; 2
  a = SWCHB; //    lda    SWCHB            ; 4
  a = a & BW_MASK; //    and    #BW_MASK         ; 2
  goto colorMode if !zero; //    bne    .colorMode       ; 2³
  y = 0x0f; //    ldy    #$0f             ; 2
colorMode:
  a = y; //    tya                     ; 2
  y = 0; //    ldy    #$00             ; 2                 disable changing colors
  bit(SS_Delay); //     bit    SS_Delay         ; 3
  goto noScreenSaver if !negative; //    bpl    .noScreenSaver   ; 2³
  a = a & 0xf7; //    and    #$f7             ; 2                 avoid bright colors in screensaver mode
  y = SS_Delay; //    ldy    SS_Delay         ; 3
noScreenSaver:
  y = SS_XOR; //    sty    SS_XOR           ; 3
  SS_XOR = SS_XOR << 1; //     asl    SS_XOR           ; 5
  SS_Mask = a; //    sta    SS_Mask          ; 3
//  ELSE
//    FILL_NOP 39
//  ENDIF
  

//; start timer for vertical sync:
//  IF NTSC
#[compile_if(NTSC)] a = 47; //    lda    #47              ; 2
//  ELSE
#[compile_if(!NTSC)] a = 79; //    lda    #79
//  ENDIF
  WSYNC = a; //    sta    WSYNC            ; 3
  TIM64T = a; //    sta    TIM64T           ; 4

//  ; read joystick:
  a = SWCHA;  //    lda    SWCHA            ; 4
  a = a >>> 1; //    lsr                     ; 2
  a = a >>> 1; //    lsr                     ; 2
  a = a >>> 1; //    lsr                     ; 2
  a = a >>> 1; //    lsr                     ; 2
  joystick = a; //  sta    joystick         ; 3
  cmp(a,NO_MOVE); //    cmp    #NO_MOVE         ; 2
  goto noMove if zero; //    beq    .noMove          ; 2³
  x = 0; //    ldx    #0               ; 2
//  IF SCREENSAVER
  SS_Delay = x; //    stx    SS_Delay         ; 3                 reset screensaver
//  ELSE
//    FILL_NOP 2
//  ENDIF
  a = timerHi; //    lda    timerHi          ; 3
  cmp(a,STARTTIME); //    cmp    #STARTTIME       ; 2                 timer at 20:00?
  goto noMove if !zero; //    bne    .noMove          ; 2³                 no, skip
  noGameScroll = x;//    stx    noGameScroll     ; 3                  yes, game is running
noMove:
  
//; read RESET switch:
  a = SWCHB;//    lda    SWCHB            ; 4
  a = a >>> 1;     //     lsr                     ; 2 RESET pressed?
  goto noReset if carry; //    bcs    .noReset         ; 2³                 no, skip
//  IF SCREENSAVER
  x = SS_Delay;  //    ldx    #SS_Delay        ; 2                  yes, load init-values offset..
//  ELSE
//    ldx    #frameCnt        ; 2                  yes, load init-values offset..
//  ENDIF
  goto Reset; //    jmp    Reset            ; 3                 ..and jump to Reset

noReset:
  a = noGameScroll; //    lda    noGameScroll     ; 3                 game running?
  goto processHarry if zero;//    beq    .processHarry    ; 2³                 yes, process Harry
  goto ProcessObjects;  //    jmp    ProcessObjects   ; 3                  no, skip Harry, goto objects
processHarry:
//  ; *** process Harry: ***
//.processHarry:
frameCnt ++;//  inc    frameCnt         ; 5
  a = random2; //    lda    random2          ; 3
  a = a << 1; //    asl                     ; 2
  a = a ^ random2; //    eor    random2          ; 3
  a = a << 1; //    asl                     ; 2
  random2 = random2 <<<<# 1; //    rol    random2          ; 5
  a = climbPos; //    lda    climbPos         ; 3                 Harry at ladder?
  goto endDoJump if !zero; //  bne    .endDoJump       ; 2³+1               no, skip continue jump
  x = jumpIndex; //  ldx    jumpIndex        ; 3                 currently jumping?
  goto endDoJump if zero; //  beq    .endDoJump       ; 2³+1               no, skip continue jump
  a = yPosHarry; //  lda    yPosHarry        ; 3                  yes, calculate..
  carry = true; //  sec                     ; 2                 ..new y-position of Harry
  a = a -#JumpTab1[x]; //  sbc    JumpTab-1,x      ; 4
  yPosHarry = a; //  sta    yPosHarry        ; 3
  jumpIndex++; //    inc    jumpIndex        ; 5
  a = jumpIndex; //     lda    jumpIndex        ; 3
  cmp(a,JUMP_LEN+1); //    cmp    #JUMP_LEN+1      ; 2
  goto indexOk if !carry; //    bcc    .indexOk         ; 2³
  a = JUMP_LEN; //    lda    #JUMP_LEN        ; 2
  jumpIndex = a; //    sta    jumpIndex        ; 3

indexOk:
  x = yPosHarry; //    ldx    yPosHarry        ; 3
  cmp(x,JUNGLE_GROUND); //    cpx    #JUNGLE_GROUND   ; 2                 Harry at jungle ground?
  goto stopJump if zero; //    beq    .stopJump        ; 2³+1               yes, stop any jump
  y = ladderFlag; //    ldy    ladderFlag       ; 3                 ladder in scene?
  goto skipFalling if zero; //    beq    .skipFalling     ; 2³+1               no, skip falling
  cmp(x,JUNGLE_GROUND + 2); //    cpx    #JUNGLE_GROUND+2 ; 2
  goto skipFalling if !zero; //    bne    .skipFalling     ; 2³+1
  a = SOUND_FALLING; //    lda    #SOUND_FALLING   ; 2                 Harry is falling into a hole
  soundIdx = a; //    sta    soundIdx         ; 3                 start falling-sound
  a = 0; //    lda    #$00             ; 2
  DecScoreHi(); //    jsr    DecScoreHi       ; 6                 subtract 100 points from score
  
skipFalling:
  cmp(x,UNDER_GROUND); //    cpx    #UNDER_GROUND    ; 2                 is Harry at underground bottom?
  goto stopJump if zero; //    beq    .stopJump        ; 2³                 yes, stop any jump
  cmp(x,54); //    cpx    #54              ; 2                 has Harry reached the falling limit?
  goto endDoJump if !zero; //    bne    .endDoJump       ; 2³                 no, skip
  a = y; //    tya                     ; 2                 ladder in scene?
  goto endDoJump if !zero; //    bne    .endDoJump       ; 2³                 no, skip kill
  goto KilledHarry; //    jmp    KilledHarry      ; 3                  yes, Harry is killed

stopJump:
  a = 0; //    lda    #0               ; 2
  jumpIndex = a; //    sta    jumpIndex        ; 3
  jumpMode = a; //    sta    jumpMode         ; 3

endDoJump:
  timerLo--;//    dec    timerLo          ; 5
  goto inTime if !negative; //    bpl    .inTime          ; 2³
  a = FRAMERATE - 1;//    lda    #FRAMERATE-1     ; 2
  timerLo = a; //    sta    timerLo          ; 3
  decimal = true; //    sed                     ; 2
  a = timerMed; //    lda    timerMed         ; 3
  carry = true; //    sec                     ; 2
  a = a -#1; //    sbc    #$01             ; 2
    goto contMinute if !carry; //    bcs    .contMinute      ; 2³
  a = 59; //    lda    #$59             ; 2                 start next minute
contMinute:
  timerMed = a; //    sta    timerMed         ; 3
  a = timerHi; //    lda    timerHi          ; 3
//    IF TRAINER
//    lda    #$19             ; 2
//  ELSE
  a = a -#0; //    sbc    #$00             ; 2
//  ENDIF
    timerHi = a; //    sta    timerHi          ; 3
  decimal = false; //    cld                     ; 2
  a = timerHi;//     lda    timerHi          ; 3                 any more..
  a = a | timerMed; //    ora    timerMed         ; 3                 ..time left?
  goto inTime if !zero; //    bne    .inTime          ; 2³                 yes, continue
  noGameScroll--; //    dec    noGameScroll     ; 5                  no, stop game
inTime:
  
//; check collisions between Harry and object:
  a = CXPPMM; //    lda    CXPPMM-$30       ; 3                 Harry collided?
  goto contCollision if negative; //    bmi    .contCollision   ; 2³                 yes, process collisions
  a = 0; //    lda    #0               ; 2                  no, skip collisions
  patOfsHarry = a; //    sta    patOfsHarry      ; 3
  goto endCollision if zero; //    beq    .endCollision    ; 3

  contCollision:
  a = yPosHarry; //    lda    yPosHarry        ; 3
  cmp(a,64); //    cmp    #64              ; 2                 Harry at underground?
  goto checkWallHit if carry; //    bcs    .checkWallHit    ; 2³                 yes, check wall
  a = atLiana; //    lda    atLiana          ; 3                  no, Harry at liana?
  goto endCollision if !zero; //    bne    .endCollision    ; 2³                 yes, skip
  a = sceneType; //    lda    sceneType        ; 3
  cmp(a,CROCO_SCENE); //    cmp    #CROCO_SCENE     ; 2                 croco in scene?
  goto endCollision if zero; //    beq    .endCollision    ; 2³                 yes, skip
  cmp(a, TREASURE_SCENE); //    cmp    #TREASURE_SCENE  ; 2                 treasue in scene?
  goto noTreasure1 if !zero; //    bne    .noTreasure1     ; 2³                 no, skip
  CheckTreasures(); //    jsr    CheckTreasures   ; 6                  yes, check if treasure was found before
  goto endCollision if !zero; //    bne    .endCollision    ; 2³
  treasureBits[x] = a; //    sta    treasureBits,x   ; 4                 clear treasure bit
  treasureCnt--; //    dec    treasureCnt      ; 5                 all treasures found
  goto incScore if !negative; //    bpl    .incScore        ; 2³                 no, skip
  noGameScroll--; //    dec    noGameScroll     ; 5                  yes, game finished!!!

  
//; treasure found, increase score:
incScore:
  a = objectType; //    lda    objectType       ; 3
  a = a & 0x03; //    and    #$03             ; 2
  a = a << 1; //    asl                     ; 2
  a = a << 1; //    asl                     ; 2
  a = a << 1; //    asl                     ; 2
  a = a << 1; //    asl                     ; 2
  a = a +#0x20; //    adc    #$20             ; 2                 add at least 2000 points
  decimal = true;  //    sed                     ; 2
  a = a +#scoreMed; //    adc    scoreMed         ; 3
  scoreMed = a; //    sta    scoreMed         ; 3
  a = 0x00; //    lda    #$00             ; 2
  a = a +#scoreHi; //    adc    scoreHi          ; 3
  scoreHi = a; //    sta    scoreHi          ; 3
  decimal = false; //    cld                     ; 2
  a = SOUND_TREASURE; //    lda    #SOUND_TREASURE  ; 2
  soundIdx = a; //    sta    soundIdx         ; 3
  goto endCollision if !zero; //    bne    .endCollision    ; 3
  
  
noTreasure1:
  a = objectType; //     lda    objectType       ; 3
  cmp(a, ID_FIRE); //    cmp    #ID_FIRE         ; 2                 fire or cobra?
  goto hitLogs if !carry;  //    bcc    .hitLogs         ; 2³                 no, hit by rolling logs
noWallHit:
  goto KilledHarry; //    jmp    KilledHarry      ; 3                 Harry is killed

  
hitLogs:
  a = climbPos; //    lda    climbPos         ; 3                 Harry at ladder?
  goto notAtLadder if zero; //    beq    .notAtLadder     ; 2³                 no, skip push
  climbPos++; //    inc    climbPos         ; 5                  yes, push down Harry
  goto decScore if !zero; //    bne    .decScore        ; 3

  
notAtLadder:
  a = yPosHarry; //    lda    yPosHarry        ; 3
  cmp(a,JUNGLE_GROUND + 1); //    cmp    #JUNGLE_GROUND+1 ; 2
  goto endCollision if carry; //    bcs    .endCollision    ; 2³
  a = 5; //    lda    #5               ; 2
  patOfsHarry = a; //    sta    patOfsHarry      ; 3
  a = objectType; //    lda    objectType       ; 3
  a = a & 0x04; //    and    #$04             ; 2
  goto decScore if !zero; //    bne    .decScore        ; 2³
  a = NO_MOVE; //    lda    #NO_MOVE         ; 2
  joystick = a; //    sta    joystick         ; 3
decScore:
  goto DecScoreLo; //    jsr    DecScoreLo       ; 6
endCollision:
  goto swingLiana; //    jmp    .swingLiana      ; 3

  
checkWallHit:
  a = wallPatPtr8[0];//wallPatPtr; //    lda    wallPatPtr       ; 3
  cmp(a,<:(&Wall)); //    cmp    #<Wall           ; 2                 wall displayed in scene?
  goto noWallHit if !zero; //    bne    .noWallHit       ; 2³                 no, skip
  a = 0x01; //    lda    #$01             ; 2                  yes, make some noise
  AUDC1 = a; //    sta    AUDC1            ; 3
  a = xPosHarry; //    lda    xPosHarry        ; 3                 determine where Harry hit the wall
  cmp(a,140); //    cmp    #140             ; 2                 right wall from the right?
  goto hitFromRight if carry; //    bcs    .hitFromRight    ; 2³                 yes, continue
  cmp(a,13); //    cmp    #13              ; 2                 left wall from the left?
  goto hitFromLeft if !carry; //    bcc    .hitFromLeft     ; 2³                 yes, continue
  cmp(a,80); //    cmp    #80              ; 2                 left or right wall?
  goto hitFromLeft if carry; //    bcs    .hitFromLeft     ; 2³
hitFromRight:
  xPosHarry++; //    inc    xPosHarry        ; 5                 bounce back one pixel and..
  x = MOVE_RIGHT; //     ldx    #MOVE_RIGHT      ; 2                 ..change direction to right
  goto contWallHit if !zero; //    bne    .contWallHit     ; 3

  
hitFromLeft:
  xPosHarry--;  //    dec    xPosHarry        ; 5                 bounce back one pixel and..
  x = MOVE_LEFT; //    ldx    #MOVE_LEFT       ; 2                 ..change direction to left

contWallHit:
  oldJoystick = x; //    stx    oldJoystick      ; 3

//  ; let the liana swing:
swingLiana:
//; calculate absolute position:
  a = lianaPosLo; //    lda    lianaPosLo       ; 3
  a = a << 1; //    asl                     ; 2
  a = lianaPosHi; //    lda    lianaPosHi       ; 3
  a = a <<<<# 1;  //   rol                     ; 2
    goto skipNeg if !negative; //     bpl    .skipNeg         ; 2³
  a = a ^ 0xff; //    eor    #$ff             ; 2
skipNeg:
  hmblAdd = a; //    sta    hmblAdd          ; 3                 store absolute value (-> angle of liana)
  y = 0xf0; //    ldy    #$f0             ; 2                 liana moves right
//  IF OPTIMIZE
//    bcs    .skipMoveLeft    ; 2³
//    FILL_NOP 2
 // ELSE
  a = lianaPosHi; //    lda    lianaPosHi       ; 3
  goto skipMoveLeft if negative; //    bmi    .skipMoveLeft    ; 2³
//  ENDIF
  y = 0x10; //    ldy    #$10             ; 2                 liana moves left
skipMoveLeft:
  hmblDir = y; //    sty    hmblDir          ; 3
  carry = true; //    sec                     ; 2
  a = 143; //    lda    #143             ; 2
  a = a -#hmblAdd; //    sbc    hmblAdd          ; 3
  carry = false; //    clc                     ; 2
  a = a +#lianaPosLo; //    adc    lianaPosLo       ; 3
  lianaPosLo = a; //    sta    lianaPosLo       ; 3
  goto skipAddHi if !carry; //    bcc    .skipAddHi       ; 2³
  a = lianaPosHi; //    lda    lianaPosHi       ; 3
  a = a +#3; //    adc    #3               ; 2
  lianaPosHi = a; //    sta    lianaPosHi       ; 3
skipAddHi:
//; calculate bottom of liana:
  a = hmblAdd; //    lda    hmblAdd          ; 3                 this are no exactly maths,..
  a = a >>> 1; //  lsr                     ; 2                 ..but who cares, as long..
  a = a >>> 1; //  lsr                     ; 2                 ..as it's looking ok :)
  a = a >>> 1; //  lsr                     ; 2
  cmp(a,6 - 1); //    cmp    #6-1             ; 2
  goto limitBottom if carry; //    bcs    .limitBottom     ; 2³                limit bottom of liana to 6
  a = 6; //    lda    #6               ; 2
limitBottom:
  a = a +#4; //    adc    #4               ; 2
  lianaBottom = a; //    sta    lianaBottom      ; 3

//; check for a new jump:
 a = jumpIndex; //  lda    jumpIndex        ; 3                 currently jumping?
  goto notJumping if zero; //    beq    .notJumping      ; 2³                 no,
  cmp(a,3); //    cmp    #3               ; 2                 jump just started?
  goto saveDir if !carry; //    bcc    .saveDir         ; 2³                 yes, save joystick direction
notJumping:
  a = a | climbPos; //    ora    climbPos         ; 3                 Harry at ladder..
  a = a | patOfsHarry; //    ora    patOfsHarry      ; 3                 ..or Harry kneeing..
  a = a | atLiana; //    ora    atLiana          ; 3                 ..or Harry at liana?
  goto noFire if !zero; //    bne    .noFire          ; 2³                 yes, skip new jump
    lda    INPT4-$30        ; 3
    and    #%10000000       ; 2
    cmp    fireButton       ; 3
    sta    fireButton       ; 3
    beq    .noFire          ; 2³
    tax                     ; 2
    bmi    .noFire          ; 2³
; start jump:
    lda    #1               ; 2                 start jumping sequence
    sta    jumpIndex        ; 3
  IF SCREENSAVER
    sta    SS_Delay         ; 3
  ELSE
    FILL_NOP 2
  ENDIF
    lda    #SOUND_JUMP      ; 2
    sta    soundIdx         ; 3
    dec    yPosHarry        ; 5                 move Harry up
.saveDir:
    lda    joystick         ; 3
    sta    oldJoystick      ; 3
.noFire:
  ProcessObjects:
  nop();
  nop();
  nop();
  nop();
  
  goto MainLoop;
  
#[fallthrough] func InitGame() {      // InitGame SUBROUTINE
  x = 0x01;              //     ldx    #1               ; 2
  random2 = x;           //     stx    random2          ; 3 
loopInitSound:
  a = 0x04;              //     lda    #$04             ; 2                 init both sound channels
  AUDV[x] = a;           //     sta    AUDV0,x          ; 4
  a = 0x10;              //     lda    #$10             ; 2
  AUDF[x] = a;           //     sta    AUDF0,x          ; 4
  x--;                   //     dex                     ; 2
  goto loopInitSound if !negative; //     bpl    .loopInitSound   ; 2³

  noGameScroll = x;      //     stx    noGameScroll     ; 3                 game is stopped
  xPosHarry = a;         //     sta    xPosHarry        ; 3
  a = a << 1;            //     asl                     ; 2
  yPosHarry = a;         //     sta    yPosHarry        ; 3
  scoreMed = a;          //     sta    scoreMed         ; 3                 = $20
//  a = STARTTIME; 
      /*    IF STARTTIME != $20
                                lda    #STARTTIME
                       ENDIF
      */
  timerHi = a;           //     sta    timerHi          ; 3

  x = 27;                //     ldx    #27              ; 2
loopInit:
  a = (&InitTab as *u8)[x];        //     lda    InitTab,x        ; 4
  PatPtr[x] = a;         //     sta    harryPatPtr,x    ; 4
  x--;                   //     dex                     ; 2
  goto loopInit if !negative; //     bpl    .loopInit        ; 2³
  a = FRAMERATE - 1; //     lda    #FRAMERATE-1     ; 2
  timerLo = a; //     sta    timerLo          ; 3
  a = 31; //     lda    #31              ; 2
  treasureCnt = a; //     sta    treasureCnt      ; 3
  a = 0b10100000; //     lda    #%10100000       ; 2                 3 lives
  livesPat = a; //     sta    livesPat         ; 3
  a = RAND_SEED; //     lda    #RAND_SEED       ; 2                 set starting scene
  random = a;   //     sta    random           ; 3
  goto ContRandom if !zero; //     bne    ContRandom       ; 3

LeftRandom:
// ; generate new random scene on the left:
loopRandom:
// ; random' = random >> 1 | (bit4^bit5^bit6^bit0) * $80
  a = random;      //     lda    random           ; 3
  a = a << 1;      //     asl                     ; 2
  a = a ^ random;  //     eor    random           ; 3
  a = a << 1;      //     asl                     ; 2
  a = a ^ random;  //     eor    random           ; 3
  a = a << 1;      //     asl                     ; 2
  a = a << 1;      //     asl                     ; 2
  a = a <<<<# 1;   //     rol                     ; 2
  a = a ^ random;  //     eor    random           ; 3
  a = a >>> 1;     //     lsr                     ; 2
  random = random >>>># 1; //  ror    random           ; 5
  x--;       //     dex                     ; 2
  goto loopRandom if !negative; //    bpl    .loopRandom      ; 2³
ContRandom:
  a = 124; //    lda    #124             ; 2                 x-position of logs, fire, cobra or treasure
  xPosObject = a; //  sta    xPosObject       ; 3
  a = random; //    lda    random           ; 3
  a = a >>> 1; //    lsr                     ; 2
  a = a >>> 1; //    lsr                     ; 2
  a = a >>> 1; //    lsr                     ; 2
  push(a);     //    pha                     ; 3
  a = a & 0b111; //     and    #%111            ; 2
  sceneType = a; //     sta    sceneType        ; 3                 bits 3..5
  a = pop();     //     pla                     ; 4
  a = a >>> 1;   //     lsr                     ; 2
  a = a >>> 1;   //     lsr                     ; 2
  a = a >>> 1;   //     lsr                     ; 2
  treePat = a;   //     sta    treePat          ; 3                 bits 6 & 7
  a = random;    //     lda    random           ; 3
  a = a & 0b111; //     and    #%111            ; 2
  objectType = a; //     sta    objectType       ; 3                 bits 0..2
  x = (SCREENWIDTH/2 - 4); //     ldx    #SCREENWIDTH/2-4 ; 2                 center x-position of scorpion
  y = NOLADDER; //     ldy    #NOLADDER        ; 2
  a = sceneType; //     lda    sceneType        ; 3
//  goto setFlag if a == (HOLE3_SCENE + 1);
  cmp(a,HOLE3_SCENE + 1);   //   cmp    #HOLE3_SCENE+1   ; 2                 scene with hole(s)?
    goto setFlag if carry;  //     bcs    .setFlag         ; 2³                 no, skip
  y = WITHLADDER;           //     ldy    #WITHLADDER      ; 2                  yes, enable ladder
  x = 17;                   //     ldx    #17              ; 2                 left wall x-position
  a = random;               //     lda    random           ; 3
  a = a << 1;               //     asl                     ; 2                 position of the wall? (bit 7)
  goto setFlag if !carry;   //     bcc    .setFlag         ; 2³                 left, skip
  x = 136;                  //     ldx    #136             ; 2                  right wall x-position
setFlag:
    ladderFlag = y;         //     sty    ladderFlag       ; 3
    xPosScorpion = x;       //     stx    xPosScorpion     ; 3                 also used for wall position
    x = sceneType;          //     ldx    sceneType        ; 3
    a = CrocoTab[x];        //     lda    CrocoTab,x       ; 4
    goto noCrocos if zero;  //     beq    .noCrocos        ; 2³
    a = 60;                 //     lda    #60              ; 2                 x-position crocos
    xPosObject = a;         //     sta    xPosObject       ; 3
noCrocos:
    return;                 //    rts                     ; 6
}
  

  const Harry5: [u8] = [
    0b00011000, // ; |   XX   |
    0b00010000, // ; |   X    |
    0b00011100, // ; |   XXX  |
    0b00011000, // ; |   XX   |
    0b00011000, // ; |   XX   |
    0b00011000, // ; |   XX   |
    0b00011000, // ; |   XX   |
    0b00011000, // ; |   XX   |
    0b00011000, // ; |   XX   |
    0b00011000, // ; |   XX   |
    0b00011000, // ; |   XX   |
    0b00011000, // ; |   XX   |
    0b00011100, // ; |   XXX  |
    0b00011110, // ; |   XXXX |
    0b00011010, // ; |   XX X |
    0b00011000, // ; |   XX   |
    0b00011000, // ; |   XX   |
    0b00010000, // ; |   X    |
    0b00011000, // ; |   XX   |
    0b00011000, // ; |   XX   |
    0b00011000, // ; |   XX   |
    0b00000000 // ; |        |
  ];

  const BranchTab : [u8] = [
    0b00011000, // ; |   XX   |
    0b01111110, // ; | XXXXXX |
    0b11011011, // ; |XX XX XX|
    0b10011001, // ; |X  XX  X|
    0b10011001, // ; |X  XX  X|
    0b10011001, // ; |X  XX  X|
    0b10011001, // ; |X  XX  X|
    0b10011001, // ; |X  XX  X|
    0b10011001, // ; |X  XX  X|
  ];
  const PF1LogTab : [u8] = [
    0b10000000, // ; |X       |
    0b00100000, // ; |  X     |
    0b00001000, // ; |    X   |
    0b00000100, // ; |     X  |
    ];
   const PF2LogTab : [u8] = [
    0b00000001, // ; |       X|
    0b00000100, // ; |     X  |
    0b00010000, // ; |   X    |
    0b00100000, // ; |  X     |
   ];
  const BranchPosLTab : [u8] = [
    0x43, 0xc3, 0x34, 0xf4
  ];
  const BranchPosRTab : [u8] = [
    0xf2, 0x72, 0x00, 0x40
  ];
  
PF2PatTab:
  const OneHole : [u8] = [
    0b01111111, // ; | XXXXXXX|        one hole
    0b01111111, // ; | XXXXXXX|
    0b01111111, // ; | XXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
  ];
  const ThreeHoles : [u8] = [
    0b01111000, // ; | XXXX   |        three holes
    0b01111000, // ; | XXXX   |
    0b01111000, // ; | XXXX   |
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
  ];
  const Pit : [u8] = [
    0b00000000, // ; |        |        pits
    0b00000001, // ; |       X|
    0b00000011, // ; |      XX|
    0b00001111, // ; |    XXXX|
    0b01111111, // ; | XXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|

    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|

    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
    0b11111111, // ; |XXXXXXXX|
  ];
  const QuickSandSize : [u8] = [
    0, 4, 8, 16, 28
  ];
  const RunColTab : [u8] = [
    DARK_GREEN,
    DARK_GREEN,
    DARK_GREEN,
    DARK_GREEN,
    DARK_GREEN,
    DARK_GREEN,
    DARK_GREEN,
    DARK_GREEN,
    DARK_GREEN,
    DARK_GREEN,
    YELLOW_GREEN,
    YELLOW_GREEN,
    YELLOW_GREEN,
    YELLOW_GREEN,
    YELLOW_GREEN,
    YELLOW_GREEN,
    YELLOW_GREEN,
    PINK,
    PINK,
    PINK,
    BROWN
  ];
  
  
  const SoundTab : [u8] = [
    0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x09, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
    0x0b, 0x0b, 0x0b, 0x0b, 0x09, 0x0b, 0x09, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x8b, 0x06,
    0x04, 0x03, 0x02, 0x84,
    0x13, 0x13, 0x0e, 0x0b, 0x09, 0x09, 0x09, 0x0b, 0x09, 0x09, 0x09, 0x89,
    0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1a, 0x1a, 0x19, 0x19, 0x19, 0x19, 0x19,
    0x19, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x14, 0x15, 0x14, 0x15, 0x14, 0x15, 0x14, 0x15, 0x14, 0x15,
    0x14, 0x95,
    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x9f
  ];
  const QuickSandTab : [u8] = [
    0b00000000, // ; |        |
    0b00001111, // ; |    XXXX|
  ];
  const QuickSandTab2 : [u8] = [
    0b00001111, // ; |    XXXX|
    0b00000000, // ; |        |
    0b00001111, //; |    XXXX|                next byte (0) overlaps
  ];
  const LadderTab : [u8] = [
    BLACKPIT|DISABLE, BLACKPIT|DISABLE, BLACKPIT|ENABLE, BLUEPIT|ENABLE,
    BLUEPIT |DISABLE, BLACKPIT|DISABLE, BLACKPIT|ENABLE, BLUEPIT|ENABLE,
    DISABLE, DISABLE, ENABLE, ENABLE  //;some bytes overlap
  ];
  
  
func CheckTreasures () {
  a = random; //    lda    random           ; 3
  a = a << 1; //    rol                     ; 2
  a = a << 1; //    rol                     ; 2
  a = a << 1; //    rol                     ; 2
  a = a & 0x03; //    and    #$03             ; 2
  x = a; //    tax                     ; 2                 bits 7 & 8
  y = objectType;  //    ldy    objectType       ; 3
  a = TreasureMask[y]; //    lda    TreasureMask,y   ; 4
  y = a; //    tay                     ; 2
  a = a & treasureBits[x];  //    and    treasureBits,x   ; 4
  push(p); //    php                     ; 3
  a = y; //    tya                     ; 2
  a = a | treasureBits[x]; //    ora    treasureBits,x   ; 4
  p = pop(); //    plp                     ; 4
  return; //    rts                     ; 6
  }
  
#[fallthrough] func KilledHarry() {
  //SUBROUTINE
  a = SOUND_DEAD; //    lda    #SOUND_DEAD      ; 2
  soundIdx = a; //    sta    soundIdx         ; 3
  a = 0x84; //    lda    #$84             ; 2                 start copyright..
  noGameScroll = a; //    sta    noGameScroll     ; 3                 ..animation
  goto ProcessObjects; //    jmp    ProcessObjects   ; 3
}
//  ; the bounds of the holes and pits where Harry falls down:
  const HoleBoundsTab : [u8] = [
    72, 
  ];
  const HoleBoundsTab1 : [u8] = [
    79,   0,  0,   0,  0,   0,  0, //   ; single hole
    44, 55,  72, 79,  96,107,   0,  0, //   ; triple hole
    44,107,   0,  0,   0,  0,   0,  0, //  ; pit
    44, 55,  64, 71,  80, 87,  96,107, //   ; closed croco jaws
    44, 61,  64, 77,  80, 93,  96,107, //   ; open croco jaws
  ];
  
  const Log0 : [u8] = [
    0b00000000, //; |        |
    0b00011000, //; |   XX   |
    0b00100100, //; |  X  X  |
    0b01011010, //; | X XX X |
    0b01011010, //; | X XX X |
    0b01011010, //; | X XX X |
    0b01100110, //; | XX  XX |
    0b01111110, //; | XXXXXX |
    0b01011110, //; | X XXXX |
    0b01110110, //; | XXX XX |
    0b01111110, //; | XXXXXX |
    0b01011110, //; | X XXXX |
    0b01110110, //; | XXX XX |
    0b00111100, //; |  XXXX  |
    0b00011000, //; |   XX   |
    0b00000000 //; |        |
  ];
  const Scorpion0 : [u8] = [
    0b10000101, // |X    X X|
    0b00110010, // |  XX  X |
    0b00111101, // |  XXXX X|
    0b01111000, // | XXXX   |
    0b11111000, // |XXXXX   |
    0b11000110, // |XX   XX |
    0b10000010, // |X     X |
    0b10010000, // |X  X    |
    0b10001000, // |X   X   |
    0b11011000, // |XX XX   |
    0b01110000, // | XXX    |
    0b00000000, // |        |
    0b00000000, // |        |
    0b00000000, // |        |
    0b00000000, // |        |
    0b00000000, // |        |
  ];
  const Scorpion1 : [u8] = [
    0b01001001, // ; | X  X  X|
    0b00110011, // ; |  XX  XX|
    0b00111100, // ; |  XXXX  |
    0b01111000, // ; | XXXX   |
    0b11111010, // ; |XXXXX X |
    0b11000100, // ; |XX   X  |
    0b10010010, // ; |X  X  X |
    0b10001000, // ; |X   X   |
    0b11011000, // ; |XX XX   |
    0b01110000, // ; | XXX    |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
  ];
  const Wall : [u8] = [
    0b11111110, //; |XXXXXXX |
    0b10111010, //; |X XXX X |
    0b10111010, //; |X XXX X |
    0b10111010, //; |X XXX X |
    0b11111110, //; |XXXXXXX |
    0b11101110, //; |XXX XXX |
    0b11101110, //; |XXX XXX |
    0b11101110, //; |XXX XXX |
    0b11111110, //; |XXXXXXX |
    0b10111010, //; |X XXX X |
    0b10111010, //; |X XXX X |
    0b10111010, //; |X XXX X |
    0b11111110, //; |XXXXXXX |
    0b11101110, //; |XXX XXX |
    0b11101110, //; |XXX XXX |
    0b11101110, //; |XXX XXX |
  ];
  const Nothing : [u8] = [
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
  ];
  const LogColor : [u8] = [
    BROWN, BROWN, BROWN, BROWN, BROWN, BROWN, BROWN, BROWN,
    BROWN, BROWN, BROWN, BROWN, BROWN, BROWN, BROWN, BROWN
  ];
  const ScorpionColor : [u8] = [
    WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE,
    WHITE, WHITE, WHITE,
    0,0,0,0,0
    ];
  
  const WallColor : [u8] = [
    GREY, DARK_RED, DARK_RED, DARK_RED, GREY, DARK_RED, DARK_RED, DARK_RED,
    GREY, DARK_RED, DARK_RED, DARK_RED, GREY, DARK_RED
  ];
//     FILL_NOP 5         ; JTZ: the scorpion is only 11 lines tall
  /*
  const InitTab : [u8] = [
    <:(&Harry5[0]),              // ; harryPatPtr
    >:(&Harry5[0]),              // ; harryPatPtr
    <:(&Log0[0]),                //  ; objPatPtr
    >:(&Log0[0]),                //  ; objPatPtr
    <:(&RunColTab[0]),            // ; harryColPtr
    >:(&RunColTab[0]),            // ; harryColPtr
    <:(&LogColor[0]),            // ; objColPtr
    >:(&LogColor[0]),            // ; objColPtr
    <:(&Wall[0]),
    >:(&Wall[0]),
    <:(&WallColor[0]),
    >:(&WallColor[0]),
    <:(&Wall[0]),
    >:(&Wall[0]),
    <:(&WallColor[0]),
    >:(&WallColor[0]),
    <:(&Space[0]),
    >:(&Space[0]),
    <:(&Space[0]),
    >:(&Space[0]),
    <:(&Two[0]),
    >:(&Two[0]),
    <:(&Zero[0]),
    >:(&Zero[0]),
    <:(&Zero[0]),
    >:(&Zero[0]),
    <:(&Zero[0]),
    >:(&Zero[0])

  ];
*/
    const InitTab : [u16] = [
    &Harry5 as u16,              // ; harryPatPtr
    &Log0 as u16,                //  ; objPatPtr
    &RunColTab as u16,            // ; harryColPtr
    &LogColor as u16,             // ; objColPtr
    &Wall as u16,
    &WallColor as u16,
    &Wall as u16,
    &WallColor as u16,
    &Space as u16,
    &Space as u16,
    &Two as u16,
    &Zero as u16,
    &Zero as u16,
    &Zero as u16
  ];
  const JumpTab : [u8] = [
//; increase/decrease y-position of jumping Harry:
    1,
  ];
  const JumpTab1 : [u8] = [
    1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1,
    254, 0, 0, 0,255, 0, 0,255, 0,255,255,255,255,255,255,255
  ];
  
  const DoublePoint : [u8] = [
    0b00000000, //; |        |
    0b00011000, //; |   XX   |
    0b00011000, //; |   XX   |
    0b00000000, //; |        |
    0b00000000, //; |        |
    0b00011000, //; |   XX   |
    0b00011000, //; |   XX   |
    0b00000000, //; |        |
  ];
  const Space : [u8] = [
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |
    0b00000000, // ; |        |    
  ];
  
  
  const TreasureMask : [u8] = [
    0b10000000,
    0b01000000,
    0b00100000,
    0b00010000,
    0b00001000,
    0b00000100,
    0b00000010,
    0b00000001
    
  ];
  
  const Zero : [u8] = [
    0b00111100, //; |  XXXX  |
    0b01100110, //; | XX  XX |
    0b01100110, //; | XX  XX |
    0b01100110, //; | XX  XX |
    0b01100110, //; | XX  XX |
    0b01100110, //; | XX  XX |
    0b01100110, //; | XX  XX |
    0b00111100, //; |  XXXX  |
  ];
  const One : [u8] = [
    0b00111100, //; |  XXXX  |
    0b00011000, //; |   XX   |
    0b00011000, //; |   XX   |
    0b00011000, //; |   XX   |
    0b00011000, //; |   XX   |
    0b00011000, //; |   XX   |
    0b00111000, //; |  XXX   |
    0b00011000, //; |   XX   |
  ];
  const Two : [u8] = [
    0b01111110, //; | XXXXXX |
    0b01100000, //; | XX     |
    0b01100000, //; | XX     |
    0b00111100, //; |  XXXX  |
    0b00000110, //; |     XX |
    0b00000110, //; |     XX |
    0b01000110, //; | X   XX |
    0b00111100, //; |  XXXX  |
  ];
  const CopyRight5 : [u8] = [
    0b00000000, //; |        |
    0b00000000, //; |        |
    0b01110111, //; | XXX XXX|
    0b01010100, //; | X X X  |
    0b01110111, //; | XXX XXX|
    0b01010001, //; | X X   X|
    0b01110111, //; | XXX XXX|
    0b00000000, //; |        |
  ];
  const ColorTab : [u8] = [
    0x0C,                  //       ; score and copyright color
    0x0C,                  //       ; unused
    DARK_GREEN,            //       ; leaves color
    GREEN,                 //       ; jungle color
    BLACK,                 //       ; hole, background and tar pit color
    (BROWN - 2),           //       ; branches and log color
    (BROWN + 2),           //       ; underground color
    (YELLOW - 6),          //       ; ground color
    BLUE                  //       ; swamp color
  ];
  
  const GroundTypeTab : [u8] = [
    <:((&OneHole as u16) - (&PF2PatTab as u16)) , //
    <:((&ThreeHoles as u16) - (&PF2PatTab as u16)) , //
    <:((&Pit as u16) - (&PF2PatTab as u16)) , //
    <:((&Pit as u16) - (&PF2PatTab as u16)) , //
    <:((&Pit as u16) - (&PF2PatTab as u16)) , //
    0x80,                       // ; black quicksand with treasure
    0x80,                       // ; black quicksand
    0x80,                       // ; blue quicksand
  ];
  const CrocoTab : [u8] = [
    CROCO_SCENE,
    1,
    7 - CROCO_SCENE
    ];
}
/*
.loopClear:
    sta    $00,x            ; 4
    txs                     ; 2
    inx                     ; 2
    bne    .loopClear       ; 2³

    jsr    InitGame         ; 6
  func main() {
    goto main;
  }
  
}
*/
in rom @ 0x1FFA {
  const = [START, START, START];
}

